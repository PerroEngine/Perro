// AUTO-GENERATED by perro_compiler. Do not edit by hand.

use perro_runtime::Runtime;
use perro_scripting::ScriptConstructor;

#[path = "scripts/script.rs"]
pub mod scripts_script_rs;

pub static SCRIPT_REGISTRY: &[(&str, ScriptConstructor<Runtime>)] = &[
    ("res://scripts/script.rs", scripts_script_rs::perro_create_script as ScriptConstructor<Runtime>),
];

#[unsafe(no_mangle)]
pub extern "C" fn perro_scripts_set_project_root(
root_ptr: *const u8,
root_len: usize,
name_ptr: *const u8,
name_len: usize,
) -> bool {
if root_ptr.is_null() || name_ptr.is_null() {
return false;
}
let root_bytes = unsafe { std::slice::from_raw_parts(root_ptr, root_len) };
let name_bytes = unsafe { std::slice::from_raw_parts(name_ptr, name_len) };
let Ok(root) = std::str::from_utf8(root_bytes) else {
return false;
};
let Ok(name) = std::str::from_utf8(name_bytes) else {
return false;
};
perro_modules::file::set_project_root_disk(root, name);
true
}

#[unsafe(no_mangle)]
pub extern "C" fn perro_script_registry_len() -> usize {
SCRIPT_REGISTRY.len()
}

#[allow(improper_ctypes_definitions)]
#[unsafe(no_mangle)]
pub extern "C" fn perro_script_registry_get(
index: usize,
path_out: *mut *const u8,
len_out: *mut usize,
ctor_out: *mut ScriptConstructor<Runtime>,
) -> bool {
if path_out.is_null() || len_out.is_null() || ctor_out.is_null() {
return false;
}
let Some((path, ctor)) = SCRIPT_REGISTRY.get(index) else {
return false;
};
unsafe {
*path_out = path.as_ptr();
*len_out = path.len();
*ctor_out = *ctor;
}
true
}
