// Auto-generated by Perro Engine compiler
use std::fs::{self, OpenOptions};
use std::io::Write;
use std::path::{Path, PathBuf};
use toml::Value;

fn main() {
    // Set up logging into build.log
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let project_root = manifest_dir
        .parent()
        .expect("Failed to get parent")
        .parent()
        .expect("Failed to get grandparent");

    let log_path = project_root.join("build.log");
    init_log(&log_path);
    log(&log_path, "=== Build Script Started ===");

    // Read project.toml
    let project_toml_path = project_root.join("project.toml");
    log(&log_path, &format!("Reading {}", project_toml_path.display()));

    let content = fs::read_to_string(&project_toml_path)
        .expect("‚ùå Could not read project.toml");
    let config: Value = content.parse().expect("‚ùå Invalid project.toml format");

    let project = config.get("project").expect("‚ùå Missing [project] section");

    let name = project
        .get("name")
        .and_then(|v| v.as_str())
        .unwrap_or("Perro Game");

    let version = project
        .get("version")
        .and_then(|v| v.as_str())
        .unwrap_or("0.1.0");

    let icon_path = project
        .get("icon")
        .and_then(|v| v.as_str())
        .unwrap_or("res://icon.png");

    log(&log_path, &format!("Project: {}", name));
    log(&log_path, &format!("Version: {}", version));
    log(&log_path, &format!("Configured icon path: {}", icon_path));

    let real_icon_path = resolve_res_path(project_root.to_path_buf(), icon_path);
    log(&log_path, &format!("Resolved icon path: {}", real_icon_path.display()));

    // Always rerun if these files or env change
    println!("cargo:rerun-if-changed={}", project_toml_path.display());
    println!("cargo:rerun-if-changed={}", real_icon_path.display());
    println!("cargo:rerun-if-env-changed=PERRO_BUILD_TIMESTAMP");

    #[cfg(target_os = "windows")]
    {
        let final_icon = ensure_ico(&real_icon_path, &project_root, &log_path);

        if final_icon.exists() {
            if let Ok(metadata) = fs::metadata(&final_icon) {
                if metadata.len() == 0 {
                    panic!("‚ùå Icon file is empty: {}", final_icon.display());
                }
                log(
                    &log_path,
                    &format!("‚úî Final ICO is valid ({} bytes)", metadata.len()),
                );
            }

            // Parse semver (major.minor.patch)
            let parts: Vec<&str> = version.split('.').collect();
            let major = parts.get(0).unwrap_or(&"0").parse::<u16>().unwrap_or(0);
            let minor = parts.get(1).unwrap_or(&"0").parse::<u16>().unwrap_or(0);
            let patch = parts.get(2).unwrap_or(&"0").parse::<u16>().unwrap_or(0);

            // Build number: from env or fallback
            let build_number: u32 = std::env::var("PERRO_BUILD_TIMESTAMP")
                .ok()
                .and_then(|s| s.parse::<u32>().ok())
                .unwrap_or_else(|| {
                    std::time::SystemTime::now()
                        .duration_since(std::time::UNIX_EPOCH)
                        .unwrap()
                        .as_secs() as u32
                });

            let version_display =
                format!("{}.{}.{}.{}", major, minor, patch, build_number);

            // Create .rc file
            let out_dir = std::env::var("OUT_DIR").unwrap();
            let rc_path = PathBuf::from(&out_dir).join("icon.rc");
            let icon_str = final_icon.to_str().unwrap().replace("\\", "\\\\");

            let rc_content = format!(
    r#"
APPICON_{} ICON "{}"

1 VERSIONINFO
FILEVERSION {},{},{},{}
PRODUCTVERSION {},{},{},{}
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904E4"
        BEGIN
            VALUE "FileDescription", "{}"
            VALUE "FileVersion", "{}"
            VALUE "ProductName", "{}"
            VALUE "ProductVersion", "{}"
            VALUE "OriginalFilename", "{}.exe"
            VALUE "Engine", "Perro"
            VALUE "EngineWebsite", "https://perroengine.com"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1252
    END
END
"#,
    build_number,
    icon_str,
    major, minor, patch, build_number,
    major, minor, patch, build_number,
    name,
    version_display,
    name,
    version_display,
    name
);

            fs::write(&rc_path, rc_content).expect("Failed to write .rc file");
            log(
                &log_path,
                &format!("‚úî Wrote RC with version {} (icon ID={})", version_display, build_number),
            );

            embed_resource::compile(&rc_path, embed_resource::NONE);
            log(&log_path, "‚úî Icon + version resource embedded successfully");
        } else {
            panic!("‚ö† Icon not found at {}", final_icon.display());
        }
    }

    #[cfg(target_os = "macos")]
    {
        setup_macos_bundle(&real_icon_path, &project_root, &log_path, name, version);
    }

    #[cfg(target_os = "linux")]
    {
        embed_linux_icon(&real_icon_path, &log_path);
        setup_linux_desktop(&real_icon_path, &project_root, &log_path, name, version);
        // Create AppImage (single file with embedded icon) after release builds
        if std::env::var("PROFILE").unwrap_or_default() == "release" {
            create_appimage(&real_icon_path, &project_root, &log_path, name, version);
        }
    }

    log(&log_path, "=== Build Script Finished ===");
}

fn init_log(path: &Path) {
    let _ = fs::remove_file(path);
    let mut f = OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(path)
        .expect("Failed to create build.log");
    writeln!(f, "Perro Build Log").unwrap();
    writeln!(f, "================").unwrap();
}

fn log(path: &Path, message: &str) {
    println!("{}", message);
    let mut f = OpenOptions::new()
        .create(true)
        .append(true)
        .open(path)
        .expect("Failed to open build.log");
    writeln!(f, "{}", message).unwrap();
}

// Default icon not found - projects must provide their own icon
const DEFAULT_ICON_BYTES: &[u8] = &[];

#[cfg(target_os = "windows")]
fn ensure_ico(path: &Path, project_root: &Path, log_path: &Path) -> PathBuf {
    if !path.exists() {
        log(log_path, &format!("‚ö† Icon file not found: {}, using default Perro icon", path.display()));
        // Use default icon if available
        if DEFAULT_ICON_BYTES.is_empty() {
            panic!("‚ùå Icon file not found: {} and no default icon available", path.display());
        }
        let default_icon_path = project_root.join("default-icon-temp.png");
        fs::write(&default_icon_path, DEFAULT_ICON_BYTES)
            .expect("Failed to write default icon");
        let ico_path = project_root.join("icon.ico");
        convert_any_image_to_ico(&default_icon_path, &ico_path, log_path);
        let _ = fs::remove_file(&default_icon_path); // Clean up temp file
        return ico_path;
    }

    let ext = path
        .extension()
        .and_then(|e| e.to_str())
        .unwrap_or("")
        .to_lowercase();

    if ext == "ico" {
        log(log_path, "Icon is already an ICO file, using directly.");
        return path.to_path_buf();
    }

    let ico_path = project_root.join("icon.ico");
    log(
        log_path,
        &format!("Converting {} ‚Üí {}", path.display(), ico_path.display()),
    );
    convert_any_image_to_ico(path, &ico_path, log_path);
    ico_path
}

#[cfg(target_os = "windows")]
fn convert_any_image_to_ico(input_path: &Path, ico_path: &Path, log_path: &Path) {
    use ico::{IconDir, IconDirEntry, IconImage, ResourceType};
    use image::io::Reader as ImageReader;
    use std::fs::File;

    if !input_path.exists() {
        panic!("‚ùå Icon path does NOT exist: {}", input_path.display());
    }

    let img = ImageReader::open(input_path)
        .expect("Failed to open image")
        .decode()
        .expect("Failed to decode image");

    let sizes = [16, 32, 48, 256];
    let mut icon_dir = IconDir::new(ResourceType::Icon);

    for size in sizes {
        let resized = img.resize_exact(size, size, image::imageops::FilterType::Lanczos3);
        let rgba = resized.into_rgba8();
        let icon_image =
            IconImage::from_rgba_data(size as u32, size as u32, rgba.into_raw());
        icon_dir.add_entry(IconDirEntry::encode(&icon_image).unwrap());
        log(log_path, &format!("‚úî Added {}x{} size to ICO", size, size));
    }

    let mut file = File::create(ico_path).expect("Failed to create ICO file");
    icon_dir
        .write(&mut file)
        .expect("Failed to write ICO file");
    log(log_path, &format!("‚úî ICO saved: {}", ico_path.display()));
}

#[cfg(target_os = "macos")]
fn setup_macos_bundle(icon_path: &Path, project_root: &Path, log_path: &Path, name: &str, version: &str) {
    let actual_icon_path = if !icon_path.exists() {
        log(log_path, &format!("‚ö† Icon file not found: {}, using default Perro icon", icon_path.display()));
        let default_icon_path = project_root.join("default-icon-temp.png");
        fs::write(&default_icon_path, DEFAULT_ICON_BYTES)
            .expect("Failed to write default icon");
        default_icon_path
    } else {
        icon_path.to_path_buf()
    };


    let icns_path = project_root.join("icon.icns");
    convert_to_icns(&actual_icon_path, &icns_path, log_path);
    if actual_icon_path.file_name().and_then(|n| n.to_str()) == Some("default-icon-temp.png") {
        let _ = fs::remove_file(&actual_icon_path); // Clean up temp file
    }

    let info_plist_path = project_root.join("Info.plist");
    let info_plist_content = format!(
        r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDisplayName</key>
    <string>{}</string>
    <key>CFBundleExecutable</key>
    <string>{}</string>
    <key>CFBundleIconFile</key>
    <string>icon.icns</string>
    <key>CFBundleIdentifier</key>
    <string>com.perroengine.{}</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>{}</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>CFBundleShortVersionString</key>
    <string>{}</string>
    <key>CFBundleVersion</key>
    <string>{}</string>
    <key>NSHighResolutionCapable</key>
    <true/>
    <key>Engine</key>
    <string>Perro</string>
    <key>EngineWebsite</key>
    <string>https://perroengine.com</string>
</dict>
</plist>"#,
        name, name, name, name, version, version
    );

    fs::write(&info_plist_path, info_plist_content).expect("Failed to write Info.plist");
    log(log_path, &format!("‚úî Created macOS bundle files: {}, {}", icns_path.display(), info_plist_path.display()));
}

#[cfg(target_os = "macos")]
fn convert_to_icns(input_path: &Path, icns_path: &Path, log_path: &Path) {
    use image::io::Reader as ImageReader;
    use std::process::Command;

    let temp_iconset = icns_path.with_extension("iconset");
    let _ = fs::create_dir_all(&temp_iconset);

    let img = ImageReader::open(input_path)
        .expect("Failed to open image")
        .decode()
        .expect("Failed to decode image");

    let sizes = [(16, "icon_16x16.png"), (32, "icon_16x16@2x.png"), (32, "icon_32x32.png"), (64, "icon_32x32@2x.png"), (128, "icon_128x128.png"), (256, "icon_128x128@2x.png"), (256, "icon_256x256.png"), (512, "icon_256x256@2x.png"), (512, "icon_512x512.png"), (1024, "icon_512x512@2x.png")];

    for (size, filename) in sizes {
        let resized = img.resize_exact(size, size, image::imageops::FilterType::Lanczos3);
        let output_path = temp_iconset.join(filename);
        resized.save(&output_path).expect("Failed to save icon size");
    }

    let output = Command::new("iconutil")
        .args(&["-c", "icns", "-o"])
        .arg(icns_path)
        .arg(&temp_iconset)
        .output();

    match output {
        Ok(result) if result.status.success() => {
            log(log_path, &format!("‚úî Created ICNS: {}", icns_path.display()));
        }
        _ => {
            log(log_path, "‚ö† iconutil failed, fallback to PNG copy");
            fs::copy(input_path, icns_path.with_extension("png")).ok();
        }
    }

    let _ = fs::remove_dir_all(&temp_iconset);
}

#[cfg(target_os = "linux")]
fn embed_linux_icon(icon_path: &Path, log_path: &Path) {
    if !icon_path.exists() {
        log(log_path, &format!("‚ö† Icon file not found: {}, skipping icon embedding", icon_path.display()));
        return;
    }

    let out_dir = std::env::var("OUT_DIR").unwrap();

    // Copy icon to OUT_DIR so we can include it
    let icon_in_out_dir = PathBuf::from(&out_dir).join("icon.png");
    fs::copy(icon_path, &icon_in_out_dir).expect("Failed to copy icon to OUT_DIR");
    log(log_path, &format!("‚úî Copied icon to OUT_DIR: {}", icon_in_out_dir.display()));

    // Generate module that embeds the icon using include_bytes!
    // This will be included in the binary's data section
    let embedded_icon_module = PathBuf::from(&out_dir).join("embedded_icon.rs");
    let module_content = format!(
        r#"// Auto-generated embedded icon module
// Icon is embedded in the binary at compile time

/// Embedded application icon (PNG bytes)
/// This icon is embedded directly in the binary's data section
pub static EMBEDDED_ICON: &[u8] = include_bytes!("icon.png");
"#
    );

    fs::write(&embedded_icon_module, module_content).expect("Failed to write embedded_icon.rs");
    log(log_path, &format!("‚úî Generated embedded icon module: {}", embedded_icon_module.display()));
}

#[cfg(target_os = "linux")]
fn setup_linux_desktop(icon_path: &Path, project_root: &Path, log_path: &Path, name: &str, version: &str) {
    let actual_icon_path = if !icon_path.exists() {
        log(log_path, &format!("‚ö† Icon file not found: {}, using default Perro icon", icon_path.display()));
        let default_icon_path = project_root.join("default-icon-temp.png");
        fs::write(&default_icon_path, DEFAULT_ICON_BYTES)
            .expect("Failed to write default icon");
        default_icon_path
    } else {
        icon_path.to_path_buf()
    };


    let icon_name = format!("{}", name.to_lowercase().replace(" ", "_"));
    let icon_dest = project_root.join(format!("{}.png", icon_name));
    let _ = fs::copy(&actual_icon_path, &icon_dest);
    if actual_icon_path.file_name().and_then(|n| n.to_str()) == Some("default-icon-temp.png") {
        let _ = fs::remove_file(&actual_icon_path); // Clean up temp file
    }
    if actual_icon_path.file_name().and_then(|n| n.to_str()) == Some("default-icon-temp.png") {
        let _ = fs::remove_file(&actual_icon_path); // Clean up temp file
    }

    // Also try to install to user's local icon directory for better file manager support
    if let Ok(home) = std::env::var("HOME") {
        let local_icons_dir = PathBuf::from(&home).join(".local/share/icons/hicolor/256x256/apps");
        if let Err(_) = fs::create_dir_all(&local_icons_dir) {
            // Silently fail if we can't create the directory
        } else {
            let system_icon_path = local_icons_dir.join(format!("{}.png", icon_name));
            if let Ok(_) = fs::copy(&actual_icon_path, &system_icon_path) {
                log(log_path, &format!("‚úî Installed icon to system location: {}", system_icon_path.display()));
            }
        }
    }

    let desktop_path = project_root.join(format!("{}.desktop", icon_name));
    // Use just the icon name (without path/extension) so file managers can find it
    // They'll look in standard icon directories
    let desktop_content = format!(
        r#"[Desktop Entry]
Name={}
Exec={}
Icon={}
Type=Application
Categories=Game;
Version={}
StartupNotify=true
Engine=Perro
EngineWebsite=https://perroengine.com
"#,
        name, icon_name, icon_name, version
    );

    fs::write(&desktop_path, desktop_content).expect("Failed to write .desktop file");
    log(log_path, &format!("‚úî Created Linux desktop files: {}, {}", icon_dest.display(), desktop_path.display()));
}

#[cfg(target_os = "linux")]
fn create_appimage(icon_path: &Path, project_root: &Path, log_path: &Path, name: &str, version: &str) {
    use std::process::Command;

    // Only create AppImage if appimagetool is available
    if Command::new("appimagetool").arg("--version").output().is_err() {
        log(log_path, "‚ö† appimagetool not found, skipping AppImage creation");
        log(log_path, "  Install with: cargo install cargo-appimage or download from https://github.com/AppImage/AppImageKit");
        return;
    }

    // Get binary name from CARGO_BIN_NAME
    let binary_name = std::env::var("CARGO_BIN_NAME")
        .unwrap_or_else(|_| name.to_lowercase().replace(" ", "_"));
    let icon_name = name.to_lowercase().replace(" ", "_");

    // Determine build directory
    let profile = std::env::var("PROFILE").unwrap_or_else(|_| "debug".to_string());
    let target_dir = std::env::var("CARGO_TARGET_DIR")
        .unwrap_or_else(|_| project_root.join("..").join("target").to_string_lossy().to_string());
    let build_dir = PathBuf::from(&target_dir).join(&profile);
    let binary = build_dir.join(&binary_name);

    if !binary.exists() {
        log(log_path, &format!("‚ö† Binary not found at {}, skipping AppImage", binary.display()));
        return;
    }

    // Create AppDir structure
    let appdir = build_dir.join("AppDir");
    let _ = fs::remove_dir_all(&appdir);
    fs::create_dir_all(appdir.join("usr/bin")).ok();
    fs::create_dir_all(appdir.join("usr/share/applications")).ok();
    fs::create_dir_all(appdir.join("usr/share/icons/hicolor/256x256/apps")).ok();

    // Copy binary
    if fs::copy(&binary, appdir.join("usr/bin").join(&binary_name)).is_err() {
        log(log_path, "‚ö† Failed to copy binary to AppDir");
        return;
    }

    // Copy icon as .DirIcon and to hicolor
    if fs::copy(icon_path, appdir.join(".DirIcon")).is_err() {
        log(log_path, "‚ö† Failed to copy icon as .DirIcon");
    }
    if fs::copy(icon_path, appdir.join("usr/share/icons/hicolor/256x256/apps").join(format!("{}.png", icon_name))).is_err() {
        log(log_path, "‚ö† Failed to copy icon to hicolor");
    }

    // Create desktop file
    let desktop_content = format!(
        r#"[Desktop Entry]
Name={}
Exec={}
Icon={}
Type=Application
Categories=Game;
Version={}
StartupNotify=true
Engine=Perro
EngineWebsite=https://perroengine.com
"#,
        name, binary_name, icon_name, version
    );

    if fs::write(appdir.join("usr/share/applications").join(format!("{}.desktop", icon_name)), &desktop_content).is_err() {
        log(log_path, "‚ö† Failed to write desktop file");
        return;
    }

    // Create AppImage
    let appimage_name = format!("{}-{}-x86_64.AppImage", binary_name, version);
    let appimage_path = build_dir.join(&appimage_name);

    log(log_path, &format!("üì¶ Creating AppImage: {}", appimage_path.display()));

    let output = Command::new("appimagetool")
        .arg(&appdir)
        .arg(&appimage_path)
        .output();

    match output {
        Ok(result) => {
            if result.status.success() {
                // Make executable
                use std::os::unix::fs::PermissionsExt;
                if let Ok(mut perms) = fs::metadata(&appimage_path).map(|m| m.permissions()) {
                    perms.set_mode(0o755);
                    fs::set_permissions(&appimage_path, perms).ok();
                }
                log(log_path, &format!("‚úî AppImage created: {}", appimage_path.display()));
            } else {
                let stderr = String::from_utf8_lossy(&result.stderr);
                log(log_path, &format!("‚ö† AppImage creation failed: {}", stderr));
            }
        }
        Err(e) => {
            log(log_path, &format!("‚ö† Failed to run appimagetool: {}", e));
        }
    }
}

fn resolve_res_path(project_root: PathBuf, res_path: &str) -> PathBuf {
    if let Some(stripped) = res_path.strip_prefix("res://") {
        project_root.join("res").join(stripped)
    } else {
        project_root.join(res_path)
    }
}
