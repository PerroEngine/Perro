#![allow(improper_ctypes_definitions)]
#![allow(unused)]

use std::any::Any;
use std::collections::HashMap;
use smallvec::{SmallVec, smallvec};
use serde_json::{Value, json};
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use std::ops::{Deref, DerefMut};
use rust_decimal::{Decimal, prelude::*};
use num_bigint::BigInt;
use std::str::FromStr;
use std::{rc::Rc, cell::RefCell};

use perro_core::prelude::*;

//=======================================;
// Auto Generated by Perro Transpiler [Any further edits to this file will be overwritten on next transile];
//=======================================;

// ========================================================================
// ScriptsCsCs - Main Script Structure
// ========================================================================

pub struct ScriptsCsCsScript {
    node: Node3D,
    speed: f32,
    health: i32,
    playerName: String,
}

// ========================================================================
// ScriptsCsCs - Creator Function (FFI Entry Point)
// ========================================================================

#[unsafe(no_mangle)]
pub extern "C" fn scripts_cs_cs_create_script() -> *mut dyn ScriptObject {
    let node = Node3D::new("ScriptsCsCs");
    let speed = 0.0f32;
    let health = 0i32;
    let playerName = String::new();

    Box::into_raw(Box::new(ScriptsCsCsScript {
        node,
        speed,
        health,
        playerName,
    })) as *mut dyn ScriptObject
}

// ========================================================================
// ScriptsCsCs - Script Init & Update Implementation
// ========================================================================

impl Script for ScriptsCsCsScript {
    fn init(&mut self, api: &mut ScriptApi<'_>) {
        self.health = 100i32;
        self.speed = 200.0ff32;
        api.print(&String::from("Player initialized!"));
    }

    fn update(&mut self, api: &mut ScriptApi<'_>) {
        self.TakeDamage(2f32, api, false);
    }

}

// ========================================================================
// ScriptsCsCs - Script-Defined Methods
// ========================================================================

impl ScriptsCsCsScript {
    fn TakeDamage(&mut self, mut amount: i32, api: &mut ScriptApi<'_>, external_call: bool) {
        self.health -= amount;
        api.print(&String::from("Took damage!"));
    }

}


impl ScriptObject for ScriptsCsCsScript {
    fn set_node_id(&mut self, id: Uuid) {
        self.node.id = id;
    }

    fn get_node_id(&self) -> Uuid {
        self.node.id
    }

    fn get_var(&self, var_id: u64) -> Option<Value> {
            VAR_GET_TABLE.get(&var_id).and_then(|f| f(self))
    }

    fn set_var(&mut self, var_id: u64, val: Value) -> Option<()> {
        VAR_SET_TABLE.get(&var_id).and_then(|f| f(self, val))
    }

    fn apply_exposed(&mut self, hashmap: &HashMap<u64, Value>) {
        for (var_id, val) in hashmap.iter() {
            if let Some(f) = VAR_APPLY_TABLE.get(var_id) {
                f(self, val);
            }
        }
    }

    fn call_function(&mut self, id: u64, api: &mut ScriptApi<'_>, params: &SmallVec<[Value; 3]>) {
        if let Some(f) = DISPATCH_TABLE.get(&id) {
            f(self, params, api);
        }
    }
}

// =========================== Static PHF Dispatch Tables ===========================

static VAR_GET_TABLE: phf::Map<u64, fn(&ScriptsCsCsScript) -> Option<Value>> = phf::phf_map! {
        2486349329025994304u64 => |script: &ScriptsCsCsScript| -> Option<Value> {
                        Some(json!(script.speed))
                    },
        9181103189905877455u64 => |script: &ScriptsCsCsScript| -> Option<Value> {
                        Some(json!(script.health))
                    },
};

static VAR_SET_TABLE: phf::Map<u64, fn(&mut ScriptsCsCsScript, Value) -> Option<()>> = phf::phf_map! {
        2486349329025994304u64 => |script: &mut ScriptsCsCsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_f64() {
                                script.speed = v as f32;
                                return Some(());
                            }
                            None
                        },
        9181103189905877455u64 => |script: &mut ScriptsCsCsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_i64() {
                                script.health = v as i32;
                                return Some(());
                            }
                            None
                        },
};

static VAR_APPLY_TABLE: phf::Map<u64, fn(&mut ScriptsCsCsScript, &Value)> = phf::phf_map! {
        2486349329025994304u64 => |script: &mut ScriptsCsCsScript, val: &Value| {
                            if let Some(v) = val.as_f64() {
                                script.speed = v as f32;
                            }
                        },
};

static DISPATCH_TABLE: phf::Map<u64, fn(&mut ScriptsCsCsScript, &[Value], &mut ScriptApi<'_>)> = phf::phf_map! {
        1329396982928406835u64 => | script: &mut ScriptsCsCsScript, params: &[Value], api: &mut ScriptApi<'_>| {
let amount = params.get(0)
                            .and_then(|v| v.as_i64().or_else(|| v.as_f64().map(|f| f as i64)))
                            .unwrap_or_default() as i32;
            script.TakeDamage(amount, api, true);
        },
};