#![allow(improper_ctypes_definitions)]
#![allow(unused)]

use std::{
    any::Any,
    cell::RefCell,
    collections::HashMap,
    ops::{Deref, DerefMut},
    rc::Rc,
    str::FromStr,
};

use num_bigint::BigInt;
use phf::{phf_map, Map};
use rust_decimal::Decimal;
use rust_decimal::prelude::{FromPrimitive, ToPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use smallvec::{smallvec, SmallVec};
use uuid::Uuid;

use perro_core::prelude::*;

//=======================================;
// Auto Generated by Perro Transpiler [Any further edits to this file will be overwritten on next transile];
//=======================================;

// ========================================================================
// Scripts3dPup - Main Script Structure
// ========================================================================

static MEMBER_TO_ATTRIBUTES_MAP: Map<&'static str, &'static [&'static str]> = phf_map! {
    "b" => &["name", "a", "bob", "Expose"],
    "init()" => &["func"],
};

static ATTRIBUTE_TO_MEMBERS_MAP: Map<&'static str, &'static [&'static str]> = phf_map! {
    "a" => &["b"],
    "bob" => &["b"],
    "name" => &["b"],
    "Expose" => &["b"],
    "func" => &["init()"],
};

pub struct Scripts3dPupScript {
    node: MeshInstance3D,
    b: f32,
}

// ========================================================================
// Scripts3dPup - Creator Function (FFI Entry Point)
// ========================================================================

#[unsafe(no_mangle)]
pub extern "C" fn scripts_3d_pup_create_script() -> *mut dyn ScriptObject {
    let node = MeshInstance3D::new("Scripts3dPup");
    let b = 5f32;

    Box::into_raw(Box::new(Scripts3dPupScript {
        node,
        b,
    })) as *mut dyn ScriptObject
}

// ========================================================================
// Scripts3dPup - Script Init & Update Implementation
// ========================================================================

impl Script for Scripts3dPupScript {
    fn init(&mut self, api: &mut ScriptApi<'_>) {
        self.node = api.get_node_clone::<MeshInstance3D>(self.node.id);
        self.node.transform.position.x = 3f32;
        api.print(&String::from("Input API Test - Testing all input methods"));

        // Merge cloned nodes
        api.merge_nodes(vec![self.node.clone().to_scene_node()]);
    }

    fn update(&mut self, api: &mut ScriptApi<'_>) {
        self.node = api.get_node_clone::<MeshInstance3D>(self.node.id);
        let mut delta: f32 = api.Time.get_delta();
        let mut move_forward_action: bool = api.Input.get_action(String::from("move_forward"));
        let mut move_backward_action: bool = api.Input.get_action(String::from("move_backward"));
        let mut move_left_action: bool = api.Input.get_action(String::from("move_left"));
        let mut move_right_action: bool = api.Input.get_action(String::from("move_right"));
        let mut jump_action: bool = api.Input.get_action(String::from("jump"));
        let mut forward_val: f32 = (move_forward_action as u8 as f32);
        let mut backward_val: f32 = (move_backward_action as u8 as f32);
        let mut left_val: f32 = (move_left_action as u8 as f32);
        let mut right_val: f32 = (move_right_action as u8 as f32);
        let mut jump_val: f32 = (jump_action as u8 as f32);
        let mut move_z: f32 = ((forward_val - backward_val) * (delta * 5.0f32));
        let mut move_x: f32 = ((left_val - right_val) * (delta * 5.0f32));
        let mut move_y: f32 = (jump_val * (delta * 5.0f32));
        self.node.transform.position.x += move_x;
        self.node.transform.position.z += move_z;
        self.node.transform.position.y += move_y;
        let mut scroll: f32 = api.Input.Mouse.get_scroll_delta();
        self.node.transform.position.y += (scroll * (delta * 2.0f32));

        // Merge cloned nodes
        api.merge_nodes(vec![self.node.clone().to_scene_node()]);
    }

}


impl ScriptObject for Scripts3dPupScript {
    fn set_node_id(&mut self, id: Uuid) {
        self.node.id = id;
    }

    fn get_node_id(&self) -> Uuid {
        self.node.id
    }

    fn get_var(&self, var_id: u64) -> Option<Value> {
        VAR_GET_TABLE.get(&var_id).and_then(|f| f(self))
    }

    fn set_var(&mut self, var_id: u64, val: Value) -> Option<()> {
        VAR_SET_TABLE.get(&var_id).and_then(|f| f(self, val))
    }

    fn apply_exposed(&mut self, hashmap: &HashMap<u64, Value>) {
        for (var_id, val) in hashmap.iter() {
            if let Some(f) = VAR_APPLY_TABLE.get(var_id) {
                f(self, val);
            }
        }
    }

    fn call_function(
        &mut self,
        id: u64,
        api: &mut ScriptApi<'_>,
        params: &SmallVec<[Value; 3]>,
    ) {
        if let Some(f) = DISPATCH_TABLE.get(&id) {
            f(self, params, api);
        }
    }

    // Attributes

    fn attributes_of(&self, member: &str) -> Vec<String> {
        MEMBER_TO_ATTRIBUTES_MAP
            .get(member)
            .map(|attrs| attrs.iter().map(|s| s.to_string()).collect())
            .unwrap_or_default()
    }

    fn members_with(&self, attribute: &str) -> Vec<String> {
        ATTRIBUTE_TO_MEMBERS_MAP
            .get(attribute)
            .map(|members| members.iter().map(|s| s.to_string()).collect())
            .unwrap_or_default()
    }

    fn has_attribute(&self, member: &str, attribute: &str) -> bool {
        MEMBER_TO_ATTRIBUTES_MAP
            .get(member)
            .map(|attrs| attrs.iter().any(|a| *a == attribute))
            .unwrap_or(false)
    }
}

// =========================== Static PHF Dispatch Tables ===========================

static VAR_GET_TABLE: phf::Map<u64, fn(&Scripts3dPupScript) -> Option<Value>> =
    phf::phf_map! {
        12638190499090526629u64 => |script: &Scripts3dPupScript| -> Option<Value> {
                        Some(json!(script.b))
                    },

    };

static VAR_SET_TABLE: phf::Map<u64, fn(&mut Scripts3dPupScript, Value) -> Option<()>> =
    phf::phf_map! {
        12638190499090526629u64 => |script: &mut Scripts3dPupScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_f64() {
                                script.b = v as f32;
                                return Some(());
                            }
                            None
                        },

    };

static VAR_APPLY_TABLE: phf::Map<u64, fn(&mut Scripts3dPupScript, &Value)> =
    phf::phf_map! {
        12638190499090526629u64 => |script: &mut Scripts3dPupScript, val: &Value| {
                            if let Some(v) = val.as_f64() {
                                script.b = v as f32;
                            }
                        },

    };

static DISPATCH_TABLE: phf::Map<
    u64,
    fn(&mut Scripts3dPupScript, &[Value], &mut ScriptApi<'_>),
> = phf::phf_map! {

    };
