#![allow(improper_ctypes_definitions)]
#![allow(unused)]

use std::{
    any::Any,
    cell::RefCell,
    collections::HashMap,
    ops::{Deref, DerefMut},
    rc::Rc,
    str::FromStr,
};

use num_bigint::BigInt;
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use smallvec::{smallvec, SmallVec};
use uuid::Uuid;
use phf::{phf_map, Map};

use perro_core::prelude::*;

//=======================================;
// Auto Generated by Perro Transpiler [Any further edits to this file will be overwritten on next transile];
//=======================================;

// ========================================================================
// Scripts3dPup - Main Script Structure
// ========================================================================

/// @PerroScript
pub struct JoyConScript {
    node: MeshInstance3D,
}

// ========================================================================
// Scripts3dPup - Creator Function (FFI Entry Point)
// ========================================================================

#[unsafe(no_mangle)]
pub extern "C" fn joycon_create_script() -> *mut dyn ScriptObject {
    let node = MeshInstance3D::new("JoyCon");

    Box::into_raw(Box::new(JoyConScript {
        node,
    })) as *mut dyn ScriptObject
}

// ========================================================================
// Scripts3dPup - Script Init & Update Implementation
// ========================================================================


impl Script for JoyConScript {
    fn init(&mut self, api: &mut ScriptApi<'_>) {
        // Enable polling - this automatically scans, connects, and starts polling
        // for all available Joy-Con devices (both V1 and V2)
        api.Input.JoyCon.enable_polling();
    }

    fn update(&mut self, api: &mut ScriptApi<'_>) {
        self.node = api.get_node_clone::<MeshInstance3D>(self.node.id);
        let mut delta = api.Time.get_delta();
        
        // Get data from all connected controllers (both Joy-Con 1 and 2)
        // Polling is now automatic when enable_polling() is called in init()
        // No need to call poll_joycon1_sync() manually anymore!
        let controllers = api.Input.JoyCon.get_data();
        
        // Default movement (if no controllers connected)
        if controllers.is_empty() {
            self.node.transform.position.x -= (0.5f32 * delta);
        } else {
            // Process each controller (works with both Joy-Con V1 and V2)
            // Data is returned as JoyconState structs - direct field access!
            for controller in controllers {
        
                // Check button states - direct struct access
                if controller.buttons.a {
                    api.print("A button pressed!");
                }
                
                if controller.buttons.b {
                    api.print("B button pressed!");
                }
                
                // Reset transform to default when X button is pressed
                if controller.buttons.x {
                    self.node.transform = Transform3D::default();
                }
                
                // Get stick data - direct struct access
                // Stick is already normalized to -1.0 to 1.0 (center at 0.0)
                let stick_h = controller.stick.x;
                let stick_v = controller.stick.y;
                
                // Move node based on stick input
                // stick_h and stick_v are already in -1.0 to 1.0 range
                
                // Get gyro data - direct struct access!
                // Gyro axes are already remapped to match engine coordinate system:
                // - X: Pitch (tilt forward/backward) → rotate_x
                // - Y: Yaw (turn left/right, up/down) → rotate_y
                // - Z: Roll (twist around long axis) → rotate_z
                // Note: Gyro values are already in radians/second (converted in the API)
                // Deadzone is already applied at the calibration level with adaptive behavior
                let gx = controller.gyro.x;
                let gy = controller.gyro.y;
                let gz = controller.gyro.z;
                
                // Apply rotations directly - axes already match engine coordinate system
                // Gyro is already in radians/second, so just multiply by delta
                self.node.transform.rotate_x(gx * delta);
                self.node.transform.rotate_y(gy * delta);
                self.node.transform.rotate_z(gz * delta);
            }
        }

        api.merge_nodes(vec![self.node.clone().to_scene_node()]);
    }

}