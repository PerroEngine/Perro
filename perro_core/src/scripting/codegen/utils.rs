// Utility functions for code generation
use crate::node_registry::NodeType;
use crate::scripting::ast::Type;
use crate::structs::engine_registry::ENGINE_REGISTRY;
use crate::structs::engine_structs::EngineStruct as EngineStructKind;

pub(crate) const TRANSPILED_IDENT: &str = "__t_";

/// Functions that should NOT be prefixed with __t_
const RESERVED_FUNCTIONS: &[&str] = &["init", "update", "fixed_update"];

/// Check if a type name is a node type
pub fn is_node_type(type_name: &str) -> bool {
    ENGINE_REGISTRY
        .node_defs
        .keys()
        .any(|node_type| format!("{:?}", node_type) == type_name)
}

/// Check if a type name is a UI element type (UIText, UIPanel, UIButton)
pub fn is_ui_element_type(type_name: &str) -> bool {
    matches!(
        type_name,
        "UIText" | "Text" | "UIPanel" | "Panel" | "UIButton" | "Button"
    )
}

/// Convert a type name string to NodeType
pub(crate) fn string_to_node_type(type_name: &str) -> Option<NodeType> {
    ENGINE_REGISTRY
        .node_defs
        .keys()
        .find(|node_type| format!("{:?}", node_type) == type_name)
        .cloned()
}

/// Check if a Type is a node type
pub fn type_is_node(typ: &Type) -> bool {
    matches!(typ, Type::Node(_) | Type::DynNode)
}

/// Check if a type becomes NodeID/TextureID/MeshID/SignalID/UIElementID or Option thereof (i.e., represents an ID).
/// Variables of these types get the _id suffix in generated Rust (e.g. var n: Node2D â†’ n_id: NodeID).
pub(crate) fn type_becomes_id(typ: &Type) -> bool {
    match typ {
        Type::Node(_) | Type::DynNode | Type::Signal | Type::UIElement(_) | Type::DynUIElement => true,
        Type::EngineStruct(EngineStructKind::Texture)
        | Type::EngineStruct(EngineStructKind::Mesh) => true,
        Type::Option(boxed) => {
            matches!(boxed.as_ref(), Type::DynNode | Type::Node(_) | Type::UIElement(_) | Type::DynUIElement)
        }
        _ => false,
    }
}

/// Rename a function: add __t_ prefix except for reserved functions
pub fn rename_function(func_name: &str) -> String {
    if RESERVED_FUNCTIONS.contains(&func_name) {
        return func_name.to_string();
    }

    if func_name.starts_with(TRANSPILED_IDENT) {
        return func_name.to_string();
    }

    format!("{}{}", TRANSPILED_IDENT, func_name)
}

/// Rename a struct: add __t_ prefix
pub fn rename_struct(struct_name: &str) -> String {
    if struct_name.starts_with(TRANSPILED_IDENT) {
        return struct_name.to_string();
    }

    format!("{}{}", TRANSPILED_IDENT, struct_name)
}

/// Rename a variable: if it's a type that becomes Uuid or Option<Uuid>, add _id suffix; otherwise add prefix
pub fn rename_variable(var_name: &str, typ: Option<&Type>) -> String {
    // Special case: "self" should NEVER be renamed - it's always self.id
    if var_name == "self" {
        return "self.id".to_string();
    }

    // Special case: temp variables should NEVER be renamed
    // These are generated by the codegen for nested API calls and other internal uses
    if var_name.starts_with("__temp_") || var_name.starts_with("__temp_api_") {
        return var_name.to_string();
    }

    // Check if already renamed (to prevent double prefixing)
    if var_name.starts_with(TRANSPILED_IDENT) {
        return var_name.to_string();
    }

    // If it's a type that becomes Uuid or Option<Uuid>, add _id suffix
    if let Some(typ) = typ {
        if type_becomes_id(typ) {
            if var_name.ends_with("_id") {
                return var_name.to_string();
            }
            return format!("{}_id", var_name);
        }
    }

    // Otherwise, transpiled identifier prefix
    format!("{}{}", TRANSPILED_IDENT, var_name)
}

/// Get the node type from a Type, if it's a Node type
pub fn get_node_type(typ: &Type) -> Option<&NodeType> {
    match typ {
        Type::Node(nt) => Some(nt),
        _ => None,
    }
}

/// If the expression is `String::from(...).to_string()`, return `String::from(...)` to avoid redundant allocation.
/// Also replaces every occurrence of that pattern when it appears inside a larger string (e.g. template output).
pub fn optimize_string_from_to_string(expr: &str) -> String {
    const PREFIX: &str = "String::from(";
    const SUFFIX: &str = ".to_string()";
    let bytes = expr.as_bytes();
    let mut result = String::with_capacity(expr.len());
    let mut i = 0usize;
    let mut broken = false;
    while i <= bytes.len().saturating_sub(PREFIX.len()) {
        if !bytes[i..].starts_with(PREFIX.as_bytes()) {
            result.push(char::from(bytes[i]));
            i += 1;
            continue;
        }
        let start = i;
        i += PREFIX.len();
        let arg_start = i;
        let mut depth = 1i32;
        while i < bytes.len() {
            let b = bytes[i];
            if b == b'"' {
                i += 1;
                while i < bytes.len() {
                    if bytes[i] == b'\\' {
                        i += 2;
                        continue;
                    }
                    if bytes[i] == b'"' {
                        i += 1;
                        break;
                    }
                    i += 1;
                }
                continue;
            }
            if b == b'(' {
                depth += 1;
            } else if b == b')' {
                depth -= 1;
                if depth == 0 {
                    let arg_end = i;
                    i += 1;
                    if i + SUFFIX.len() <= bytes.len() && bytes[i..].starts_with(SUFFIX.as_bytes()) {
                        result.push_str(PREFIX);
                        result.push_str(std::str::from_utf8(&bytes[arg_start..arg_end]).unwrap_or(""));
                        result.push(')');
                        i += SUFFIX.len();
                    } else {
                        result.push_str(&expr[start..i]);
                    }
                    break;
                }
            }
            i += 1;
        }
        if depth != 0 {
            result.push_str(std::str::from_utf8(&bytes[start..]).unwrap_or(""));
            broken = true;
            break;
        }
    }
    if !broken && i < bytes.len() {
        result.push_str(&expr[i..]);
    }
    if result.is_empty() {
        expr.to_string()
    } else {
        result
    }
}

/// If the expression is `String::from("literal").as_str()`, return `"literal"` to avoid allocation.
/// Handles escaped quotes inside the literal. Returns the original string if the pattern doesn't match.
pub fn optimize_string_from_as_str(expr: &str) -> String {
    let trimmed = expr.trim();
    const PREFIX: &str = "String::from(\"";
    const SUFFIX: &str = "\").as_str()";
    if !trimmed.starts_with(PREFIX) || !trimmed.ends_with(SUFFIX) {
        return expr.to_string();
    }
    let rest = &trimmed[PREFIX.len()..trimmed.len() - SUFFIX.len()];
    let mut content_end_byte = None;
    let mut chars = rest.char_indices();
    while let Some((i, c)) = chars.next() {
        match c {
            '\\' => {
                chars.next();
            }
            '"' => {
                content_end_byte = Some(i);
                break;
            }
            _ => {}
        }
    }
    match content_end_byte {
        Some(end) => format!("\"{}\"", &rest[..end]),
        // No internal quote: entire `rest` is the literal (e.g. "MaybeMissing")
        None => format!("\"{}\"", rest),
    }
}

/// If the expression is `&String::from("literal")`, return `"literal"` to avoid allocation.
/// Handles escaped quotes inside the literal. Returns the original string if the pattern doesn't match.
pub fn optimize_string_from_ref(expr: &str) -> String {
    let trimmed = expr.trim();
    const PREFIX: &str = "&String::from(\"";
    const SUFFIX: &str = "\")";
    if !trimmed.starts_with(PREFIX) || !trimmed.ends_with(SUFFIX) {
        return expr.to_string();
    }
    let rest = &trimmed[PREFIX.len()..trimmed.len() - SUFFIX.len()];
    let mut content_end_byte = None;
    let mut chars = rest.char_indices();
    while let Some((i, c)) = chars.next() {
        match c {
            '\\' => {
                chars.next();
            }
            '"' => {
                content_end_byte = Some(i);
                break;
            }
            _ => {}
        }
    }
    match content_end_byte {
        Some(end) => format!("\"{}\"", &rest[..end]),
        None => format!("\"{}\"", rest),
    }
}

/// If the expression is `&<expr>.clone()`, drop the clone and return `&<expr>`.
/// Returns the original string if the pattern doesn't match.
pub fn optimize_ref_clone(expr: &str) -> String {
    let trimmed = expr.trim();
    if trimmed.starts_with('&') && trimmed.ends_with(".clone()") {
        let inner = &trimmed[1..trimmed.len() - ".clone()".len()];
        return format!("&{}", inner.trim());
    }
    expr.to_string()
}

/// Convert a string to PascalCase
pub(crate) fn to_pascal_case(s: &str) -> String {
    if s.is_empty() {
        return String::new();
    }
    s.split('_')
        .filter(|part| !part.is_empty())
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                Some(first) => {
                    first.to_uppercase().collect::<String>() + &chars.as_str().to_lowercase()
                }
                None => String::new(),
            }
        })
        .collect()
}
