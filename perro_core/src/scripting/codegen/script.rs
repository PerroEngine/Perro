// Script code generation - main to_rust method
use crate::ast::*;
use crate::scripting::ast::{Expr, Literal};
use crate::structs::engine_structs::EngineStruct as EngineStructKind;
use std::fmt::Write as _;
use std::path::Path;
use regex::Regex;
use super::cache::{clear_type_cache, clear_script_members_cache};
use super::utils::{to_pascal_case, rename_variable};
use super::analysis::analyze_self_usage;
use super::boilerplate::implement_script_boilerplate;
use super::file_io::write_to_crate;

impl Script {
    pub fn to_rust(
        &mut self,
        struct_name: &str,
        project_path: &Path,
        current_func: Option<&Function>,
        verbose: bool,
        module_names: &std::collections::HashSet<String>,
        module_name_to_identifier: &std::collections::HashMap<String, String>,
        module_functions: &std::collections::HashMap<String, Vec<Function>>,
        module_variables: &std::collections::HashMap<String, Vec<Variable>>,
    ) -> String {
        self.verbose = verbose;
        // Clear caches at the start of codegen
        clear_type_cache();
        clear_script_members_cache();

        let mut script = self.clone();
        // Store module names and mapping in script for use during codegen
        script.module_names = module_names.clone();
        script.module_name_to_identifier = module_name_to_identifier.clone();
        script.module_functions = module_functions.clone();
        script.module_variables = module_variables.clone();
        // Analyze self usage and call propagation before codegen
        analyze_self_usage(&mut script);

        let mut out = String::with_capacity(8192);
        let pascal_struct_name = to_pascal_case(struct_name);

        // Headers / Lints
        out.push_str("#![allow(improper_ctypes_definitions)]\n");
        out.push_str("#![allow(unused)]\n");
        out.push_str("#![allow(non_snake_case)]\n");
        out.push_str("#![allow(non_camel_case_types)]\n");
        out.push_str("#![allow(non_upper_case_globals)]\n\n");

        // Standard library imports
        out.push_str("use std::{\n");
        out.push_str("    any::Any,\n");
        out.push_str("    borrow::Cow,\n");
        out.push_str("    cell::RefCell,\n");
        out.push_str("    collections::HashMap,\n");
        out.push_str("    ops::{Deref, DerefMut},\n");
        out.push_str("    rc::Rc,\n");
        out.push_str("    str::FromStr,\n");
        out.push_str("};\n\n");

        // External crates
        out.push_str("use num_bigint::BigInt;\n");
        out.push_str("use phf::{phf_map, Map};\n");
        out.push_str("use rust_decimal::Decimal;\n");
        out.push_str("use rust_decimal::prelude::{FromPrimitive, ToPrimitive};\n");
        out.push_str("use serde::{Deserialize, Serialize};\n");
        out.push_str("use serde_json::{json, Value};\n");
        out.push_str("use smallvec::{smallvec, SmallVec};\n");
        out.push_str("use perro_core::{TextureID, NodeID, MaterialID, MeshID, LightID, UIElementID};\n\n");

        // Internal modules
        out.push_str("use perro_core::prelude::*;\n\n");

        out.push_str("//=======================================;\n");
        out.push_str("// Auto Generated by Perro Transpiler [Any further edits to this file will be overwritten on next transile];\n");
        out.push_str("//=======================================;\n\n");

        // Generate constant for source location tracking
        let script_file = script.source_file.as_ref()
            .map(|f| {
                f.split('/').last().unwrap_or(f).to_string()
            })
            .unwrap_or_else(|| {
                let base_name = struct_name.strip_suffix("_pup").unwrap_or(struct_name);
                format!("{}.pup", base_name)
            });
        
        write!(out, "const __PERRO_SOURCE_FILE: &str = \"{}\";\n\n", script_file).unwrap();

        let all_script_vars = &script.variables;

        // Main Script Structure
        out.push_str("// ========================================================================\n");
        write!(out, "// {} - Main Script Structure\n", pascal_struct_name).unwrap();
        out.push_str("// ========================================================================\n\n");

        // Build reverse index: attribute -> members
        let mut attribute_to_members: std::collections::HashMap<String, Vec<String>> =
            std::collections::HashMap::new();

        out.push_str("static MEMBER_TO_ATTRIBUTES_MAP: Map<&'static str, &'static [&'static str]> = phf_map! {\n");
        for var in &script.variables {
            let attrs = script
                .attributes
                .get(&var.name)
                .cloned()
                .unwrap_or_else(|| var.attributes.clone());
            if !attrs.is_empty() {
                write!(out, "    \"{}\" => &[", var.name).unwrap();
                for (i, attr) in attrs.iter().enumerate() {
                    if i > 0 {
                        out.push_str(", ");
                    }
                    write!(out, "\"{}\"", attr).unwrap();
                    attribute_to_members
                        .entry(attr.clone())
                        .or_insert_with(Vec::new)
                        .push(var.name.clone());
                }
                out.push_str("],\n");
            }
        }
        for func in &script.functions {
            let func_key = format!("{}()", func.name);
            let attrs = script
                .attributes
                .get(&func.name)
                .cloned()
                .unwrap_or_else(|| func.attributes.clone());
            if !attrs.is_empty() {
                write!(out, "    \"{}\" => &[", func_key).unwrap();
                for (i, attr) in attrs.iter().enumerate() {
                    if i > 0 {
                        out.push_str(", ");
                    }
                    write!(out, "\"{}\"", attr).unwrap();
                    attribute_to_members
                        .entry(attr.clone())
                        .or_insert_with(Vec::new)
                        .push(func_key.clone());
                }
                out.push_str("],\n");
            }
        }
        for struct_def in &script.structs {
            for field in &struct_def.fields {
                let qualified_name = format!("{}.{}", struct_def.name, field.name);
                let attrs = script
                    .attributes
                    .get(&qualified_name)
                    .cloned()
                    .unwrap_or_else(|| field.attributes.clone());
                if !attrs.is_empty() {
                    write!(out, "    \"{}\" => &[", qualified_name).unwrap();
                    for (i, attr) in attrs.iter().enumerate() {
                        if i > 0 {
                            out.push_str(", ");
                        }
                        write!(out, "\"{}\"", attr).unwrap();
                        attribute_to_members
                            .entry(attr.clone())
                            .or_insert_with(Vec::new)
                            .push(qualified_name.clone());
                    }
                    out.push_str("],\n");
                }
            }
        }
        out.push_str("};\n\n");

        // Generate reverse index for O(1) attribute lookups
        out.push_str("static ATTRIBUTE_TO_MEMBERS_MAP: Map<&'static str, &'static [&'static str]> = phf_map! {\n");
        for (attr, members) in &attribute_to_members {
            write!(out, "    \"{}\" => &[", attr).unwrap();
            for (i, member) in members.iter().enumerate() {
                if i > 0 {
                    out.push_str(", ");
                }
                write!(out, "\"{}\"", member).unwrap();
            }
            out.push_str("],\n");
        }
        out.push_str("};\n\n");

        write!(out, "pub struct {}Script {{\n", pascal_struct_name).unwrap();
        write!(out, "    id: NodeID,\n").unwrap();

        for var in all_script_vars {
            let renamed_name = rename_variable(&var.name, var.typ.as_ref());
            // Special case: Texture (EngineStruct) becomes Option<TextureID> in Rust struct fields
            let rust_type = match var.typ.as_ref() {
                Some(Type::EngineStruct(EngineStructKind::Texture)) => {
                    "Option<TextureID>".to_string()
                }
                _ => var.rust_type(),
            };
            write!(out, "    {}: {},\n", renamed_name, rust_type).unwrap();
        }

        out.push_str("}\n\n");

        out.push_str("// ========================================================================\n");
        write!(out, "// {} - Creator Function (FFI Entry Point)\n", pascal_struct_name).unwrap();
        out.push_str("// ========================================================================\n\n");

        out.push_str("#[unsafe(no_mangle)]\n");
        write!(
            out,
            "pub extern \"C\" fn {}_create_script() -> *mut dyn ScriptObject {{\n",
            struct_name.to_lowercase()
        )
        .unwrap();

        write!(
            out,
            "    let id = NodeID::nil(); // Will be set when attached to node\n"
        )
        .unwrap();

        // Emit local variable predefinitions for all fields
        for var in all_script_vars {
            let name = &var.name;
            let mut init_code = var.rust_initialization(&script, current_func);

            if init_code.contains("self.") {
                init_code = init_code.replace("self.", "");
            }

            let re_ident = Regex::new(r"\b([A-Za-z_][A-Za-z0-9_]*)\b").unwrap();

            let mut referenced_vars = Vec::new();
            for cap in re_ident.captures_iter(&init_code) {
                let ref_name = cap[1].to_string();

                if ref_name == *name
                   || !all_script_vars.iter().any(|v| v.name == ref_name)
                    || !ref_name.chars().next().map_or(false, |c| c.is_lowercase())
                    || ["let", "mut", "new", "HashMap", "vec", "json"].contains(&ref_name.as_str())
                {
                    continue;
                }

                referenced_vars.push(ref_name);
            }

            // If any referenced variable is non-Copy, ensure ".clone()"
            for ref_name in referenced_vars {
                if let Some(ref_type) = script.get_variable_type(&ref_name) {
                    if ref_type.requires_clone() {
                        let re_replace =
                            Regex::new(&format!(r"\b{}\b", regex::escape(&ref_name))).unwrap();
                        if !init_code.contains(&format!("{}.clone()", ref_name)) {
                            init_code = re_replace
                                .replace_all(&init_code, format!("{}.clone()", ref_name))
                                .to_string();
                        }
                    }
                }
            }

            write!(out, "    let {} = {};\n", name, init_code).unwrap();
        }

        // Emit actual struct construction
        write!(
            out,
            "\n    Box::into_raw(Box::new({}Script {{\n",
            pascal_struct_name
        )
        .unwrap();

        write!(out, "        id,\n").unwrap();
        for var in all_script_vars {
            let renamed_name = rename_variable(&var.name, var.typ.as_ref());
            let name = &var.name;
            write!(out, "        {}: {},\n", renamed_name, name).unwrap();
        }

        out.push_str("    })) as *mut dyn ScriptObject\n");
        out.push_str("}\n\n");

        if !script.structs.is_empty() {
            out.push_str("// ========================================================================\n");
            out.push_str("// Supporting Struct Definitions\n");
            out.push_str("// ========================================================================\n\n");

            for s in &script.structs {
                out.push_str(&s.to_rust_definition(&script));
                out.push_str("\n\n");
            }
        }

        out.push_str("// ========================================================================\n");
        write!(
            out,
            "// {} - Script Init & Update Implementation\n",
            pascal_struct_name
        )
        .unwrap();
        out.push_str("// ========================================================================\n\n");

        write!(out, "impl Script for {}Script {{\n", pascal_struct_name).unwrap();

        for func in &script.functions {
            if func.is_trait_method {
                out.push_str(&func.to_rust_trait_method(&script.node_type, &script));
            }
        }
        out.push_str("}\n\n");

        let helpers: Vec<_> = script
            .functions
            .iter()
            .filter(|f| !f.is_trait_method)
            .collect();
        if !helpers.is_empty() {
            out.push_str("// ========================================================================\n");
            write!(out, "// {} - Script-Defined Methods\n", pascal_struct_name).unwrap();
            out.push_str("// ========================================================================\n\n");

            write!(out, "impl {}Script {{\n", pascal_struct_name).unwrap();
            for func in helpers {
                out.push_str(&func.to_rust_method(&script.node_type, &script));
            }
            out.push_str("}\n\n");
        }

        out.push_str(&implement_script_boilerplate(
            &format!("{}Script", pascal_struct_name),
            &script.variables,
            &script.functions,
            &script.attributes,
        ));

        if let Err(e) = write_to_crate(&project_path, &out, struct_name) {
            eprintln!("Warning: Failed to write to crate: {}", e);
        }

        out
    }
}

impl Module {
    pub fn to_rust(
        &self,
        module_name: &str,
        project_path: &Path,
        verbose: bool,
        module_names: &std::collections::HashSet<String>,
        project_mode: bool,
    ) -> String {
        let mut out = String::with_capacity(4096);

        // Headers / Lints
        out.push_str("#![allow(improper_ctypes_definitions)]\n");
        out.push_str("#![allow(unused)]\n");
        out.push_str("#![allow(non_snake_case)]\n\n");

        // Standard library imports (minimal for modules)
        out.push_str("use std::collections::HashMap;\n");
        out.push_str("use serde_json::{json, Value};\n");
        out.push_str("use perro_core::prelude::*;\n");
        out.push_str("use perro_core::scripting::api::ScriptApi;\n\n");

        out.push_str("//=======================================;\n");
        out.push_str("// Auto Generated by Perro Transpiler [Any further edits to this file will be overwritten on next transpile];\n");
        out.push_str("//=======================================;\n\n");

        // Generate constant for source location tracking
        let module_file = self.source_file.as_ref()
            .map(|f| {
                f.split('/').last().unwrap_or(f).to_string()
            })
            .unwrap_or_else(|| {
                format!("{}.pup", self.module_name)
            });
        
        write!(out, "const __PERRO_SOURCE_FILE: &str = \"{}\";\n\n", module_file).unwrap();

        // Wrap everything in a pub mod block with the module name
        // The module name from @module declaration
        write!(out, "pub mod {} {{\n", self.module_name).unwrap();
        out.push_str("    use super::*;\n\n");

        // Generate structs first (if any)
        if !self.structs.is_empty() {
            out.push_str("    // ========================================================================\n");
            out.push_str("    // Supporting Struct Definitions\n");
            out.push_str("    // ========================================================================\n\n");

            for s in &self.structs {
                // Indent struct definitions
                let struct_code = s.to_rust_definition_for_module();
                for line in struct_code.lines() {
                    out.push_str("    ");
                    out.push_str(line);
                    out.push_str("\n");
                }
                out.push_str("\n");
            }
        }

        // Generate constants/variables
        if !self.variables.is_empty() {
            out.push_str("    // ========================================================================\n");
            out.push_str("    // Module Constants\n");
            out.push_str("    // ========================================================================\n\n");

            for var in &self.variables {
                if let Some(typ) = &var.typ {
                    let rust_type = typ.to_rust_type();
                    let value = if let Some(expr) = &var.value {
                        // For constants, we need to generate the expression value
                        // Use the same literal conversion logic as regular expressions
                        match &expr.expr {
                            Expr::Literal(lit) => {
                                // Pass the expected type to get proper type suffixes (e.g., 5i32, 5f32)
                                lit.to_rust(Some(typ))
                            }
                            _ => typ.rust_default_value(),
                        }
                    } else {
                        typ.rust_default_value()
                    };
                    // All module variables are const in Rust; use transpiled ident on definition
                    // (Rust doesn't allow #[inline] on constants, only on functions)
                    let renamed_name = rename_variable(&var.name, var.typ.as_ref());
                    write!(out, "    pub const {}: {} = {};\n", renamed_name, rust_type, value).unwrap();
                }
            }
            out.push_str("\n");
        }

        // Generate free functions
        if !self.functions.is_empty() {
            out.push_str("    // ========================================================================\n");
            out.push_str("    // Module Functions\n");
            out.push_str("    // ========================================================================\n\n");

            for func in &self.functions {
                // Indent function definitions; add #[inline] in project mode
                if project_mode {
                    out.push_str("    #[inline]\n");
                }
                let func_code = func.to_rust_free_function(verbose, module_names, Some(&self.variables));
                for line in func_code.lines() {
                    out.push_str("    ");
                    out.push_str(line);
                    out.push_str("\n");
                }
                out.push_str("\n");
            }
        }

        out.push_str("}\n");

        // Write to crate
        if let Err(e) = write_to_crate(&project_path, &out, module_name) {
            eprintln!("Warning: Failed to write module to crate: {}", e);
        }

        out
    }
}
