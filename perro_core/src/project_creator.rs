//! Project creation utilities for Perro Engine
//! Can be used from CLI or editor API

use std::fs;
use std::path::{Path, PathBuf};

/// Create a new Perro project at the specified path
///
/// # Arguments
/// * `project_name` - Name of the project (must be valid Rust identifier)
/// * `project_path` - Path where the project should be created
/// * `from_source` - If true, uses relative path to perro_core. If false, uses crates.io dependency
/// * `quiet` - If true, suppresses verbose output (useful when called from API)
pub fn create_new_project(
    project_name: &str,
    project_path: &Path,
    from_source: bool,
    quiet: bool,
) -> Result<(), String> {
    // Validate project name (must be valid Rust identifier)
    if !is_valid_project_name(project_name) {
        return Err(format!(
            "Invalid project name: '{}'. Project names must be valid Rust identifiers (alphanumeric + underscore, no spaces)",
            project_name
        ));
    }

    // Check if path already exists
    if project_path.exists() {
        return Err(format!("Path already exists: {}", project_path.display()));
    }

    // Create project directory structure first (needed for path calculation)
    if !quiet {
        println!(
            "ðŸ“ Creating project structure at: {}",
            project_path.display()
        );
    }

    // Create root directory
    fs::create_dir_all(project_path)
        .map_err(|e| format!("Failed to create project directory: {}", e))?;

    // Create .perro directory structure first (needed for path calculation)
    let perro_dir = project_path.join(".perro");
    fs::create_dir_all(&perro_dir)
        .map_err(|e| format!("Failed to create .perro directory: {}", e))?;

    // Create .perro/project directory (needed before canonicalize in calculate_perro_core_path)
    let project_crate_dir = perro_dir.join("project");
    fs::create_dir_all(&project_crate_dir)
        .map_err(|e| format!("Failed to create .perro/project directory: {}", e))?;

    // Calculate perro_core dependency path (after creating directory so canonicalize works)
    let perro_core_dep = if from_source {
        // Calculate relative path from project to perro_core
        calculate_perro_core_path(project_path)?
    } else {
        // Use crates.io version from Cargo.toml
        let version = env!("CARGO_PKG_VERSION");
        format!("perro_core = \"{}\"", version)
    };

    // Note: .perro/project/src/ directory is created by the compiler
    // We don't create it here to avoid git tracking generated files

    // Create .perro/scripts directory
    let scripts_crate_dir = perro_dir.join("scripts");
    fs::create_dir_all(&scripts_crate_dir)
        .map_err(|e| format!("Failed to create .perro/scripts directory: {}", e))?;

    // Note: .perro/scripts/src/ directory is created by the transpiler
    // We don't create it here to avoid git tracking generated files

    // Create res directory
    let res_dir = project_path.join("res");
    fs::create_dir_all(&res_dir).map_err(|e| format!("Failed to create res directory: {}", e))?;

    // Write project.toml
    let project_toml = generate_project_toml(project_name);
    fs::write(project_path.join("project.toml"), project_toml)
        .map_err(|e| format!("Failed to write project.toml: {}", e))?;

    // Write default main.scn scene file
    let main_scn = generate_main_scn();
    fs::write(res_dir.join("main.scn"), main_scn)
        .map_err(|e| format!("Failed to write res/main.scn: {}", e))?;

    // Write .gitignore
    let gitignore = generate_gitignore();
    fs::write(project_path.join(".gitignore"), gitignore)
        .map_err(|e| format!("Failed to write .gitignore: {}", e))?;

    // Write .perro/project/Cargo.toml
    let project_cargo_toml = generate_project_cargo_toml(project_name, &perro_core_dep);
    fs::write(project_crate_dir.join("Cargo.toml"), project_cargo_toml)
        .map_err(|e| format!("Failed to write .perro/project/Cargo.toml: {}", e))?;

    // Note: build.rs and main.rs are generated by the compiler during build
    // We don't need to create them here

    // Write .perro/scripts/Cargo.toml
    // Note: The scripts Cargo.toml is in .perro/scripts/, so we need to adjust the path
    // by adding two more ../ levels to account for .perro/scripts/
    let scripts_perro_core_dep = if from_source {
        // Adjust the path: if project path is "../../perro_core", scripts needs "../../../../perro_core"
        let adjusted_path = calculate_perro_core_path_for_scripts(project_path)?;
        adjusted_path
    } else {
        perro_core_dep.clone()
    };
    let scripts_cargo_toml = generate_scripts_cargo_toml(&scripts_perro_core_dep);
    fs::write(scripts_crate_dir.join("Cargo.toml"), scripts_cargo_toml)
        .map_err(|e| format!("Failed to write .perro/scripts/Cargo.toml: {}", e))?;

    // Note: lib.rs and src/ directory are generated by the transpiler during build
    // We don't need to create them here

    if !quiet {
        println!("âœ… Project '{}' created successfully!", project_name);
        println!("ðŸ“‚ Project location: {}", project_path.display());
        println!("\nNext steps:");
        println!("  1. Add your scenes and scripts to res/");
        println!("\n  Development workflow:");
        println!("\x1b[36m     â€¢ Transpile & compile scripts (for testing changes):\x1b[0m");
        println!(
            "\x1b[33m       cargo run -p perro_core -- --path {} --scripts\x1b[0m",
            project_path.display()
        );
        println!("\x1b[36m     â€¢ Build scripts and run dev project (all-in-one):\x1b[0m");
        println!(
            "\x1b[33m       cargo run -p perro_core -- --path {} --dev\x1b[0m",
            project_path.display()
        );
        println!(
            "\x1b[90m       (This is equivalent to: --scripts + cargo run -p perro_dev)\x1b[0m"
        );
        println!("\x1b[36m     â€¢ Just run project (no compilation, scripts must be built):\x1b[0m");
        println!(
            "\x1b[33m       cargo run -p perro_core -- --path {} --run\x1b[0m",
            project_path.display()
        );
        println!("\x1b[36m     â€¢ Or run dev project separately:\x1b[0m");
        println!(
            "\x1b[33m       cargo run -p perro_dev -- --path {}\x1b[0m",
            project_path.display()
        );
        println!("\n  Release build:");
        println!("\x1b[36m     â€¢ Build final release (compiles everything):\x1b[0m");
        println!(
            "\x1b[33m       cargo run -p perro_core -- --path {} --project\x1b[0m",
            project_path.display()
        );
        println!("\x1b[36m     â€¢ Build verbose release (with console window):\x1b[0m");
        println!(
            "\x1b[33m       cargo run -p perro_core -- --path {} --project --verbose\x1b[0m",
            project_path.display()
        );
    }

    Ok(())
}

/// Calculate relative path from .perro/project/ to perro_core
fn calculate_perro_core_path(project_path: &Path) -> Result<String, String> {
    use dunce;

    // The Cargo.toml is in .perro/project/, so we need to calculate relative to that
    let project_cargo_dir = project_path.join(".perro/project");

    // Ensure the directory exists before canonicalizing
    if !project_cargo_dir.exists() {
        return Err(format!(
            "Directory does not exist: {}. This should have been created before calling calculate_perro_core_path",
            project_cargo_dir.display()
        ));
    }

    let project_cargo_abs = dunce::canonicalize(&project_cargo_dir).map_err(|e| {
        format!(
            "Failed to canonicalize .perro/project path: {} (path: {})",
            e,
            project_cargo_dir.display()
        )
    })?;

    let mut current = project_path.to_path_buf();
    if let Ok(canon) = dunce::canonicalize(&current) {
        current = canon;
    }

    // Walk up to find workspace root
    loop {
        let workspace_cargo = current.join("Cargo.toml");
        if workspace_cargo.exists() {
            // Check if this workspace contains perro_core
            let perro_core_path = current.join("perro_core");
            if perro_core_path.exists() && perro_core_path.join("Cargo.toml").exists() {
                // Calculate relative path from .perro/project/ to perro_core
                let perro_core_abs = dunce::canonicalize(&perro_core_path)
                    .map_err(|e| format!("Failed to canonicalize perro_core path: {}", e))?;

                // Calculate relative path manually
                let relative = calculate_relative_path(&project_cargo_abs, &perro_core_abs)?;

                // Convert to forward slashes for cross-platform compatibility
                let path_str = relative.replace('\\', "/");
                return Ok(format!("perro_core = {{ path = \"{}\" }}", path_str));
            }
        }

        // Move up one level
        match current.parent() {
            Some(parent) => current = parent.to_path_buf(),
            None => break,
        }
    }

    // Fallback: try to find perro_core relative to current executable
    // This handles the case when running from cargo run
    if let Ok(exe) = std::env::current_exe() {
        if let Some(exe_dir) = exe.parent() {
            let mut current = exe_dir.to_path_buf();
            for _ in 0..10 {
                // Limit search depth
                let perro_core_path = current.join("perro_core");
                if perro_core_path.exists() && perro_core_path.join("Cargo.toml").exists() {
                    let perro_core_abs = dunce::canonicalize(&perro_core_path)
                        .map_err(|e| format!("Failed to canonicalize perro_core path: {}", e))?;

                    let relative = calculate_relative_path(&project_cargo_abs, &perro_core_abs)?;
                    let path_str = relative.replace('\\', "/");
                    return Ok(format!("perro_core = {{ path = \"{}\" }}", path_str));
                }

                match current.parent() {
                    Some(parent) => current = parent.to_path_buf(),
                    None => break,
                }
            }
        }
    }

    // If we can't find it, use a default relative path
    // From .perro/project/ to workspace root/perro_core: ../../perro_core
    Ok("perro_core = { path = \"../../perro_core\" }".to_string())
}

/// Calculate relative path from scripts Cargo.toml (.perro/scripts/) to perro_core
/// This adds two more ../ levels compared to the project root path
fn calculate_perro_core_path_for_scripts(project_path: &Path) -> Result<String, String> {
    use dunce;

    let project_abs = dunce::canonicalize(project_path)
        .map_err(|e| format!("Failed to canonicalize project path: {}", e))?;

    // Scripts Cargo.toml is at project_path/.perro/scripts/
    let scripts_cargo_path = project_abs.join(".perro").join("scripts");

    // Find perro_core (same logic as calculate_perro_core_path)
    let mut current = project_abs.clone();

    loop {
        let workspace_cargo = current.join("Cargo.toml");
        if workspace_cargo.exists() {
            let perro_core_path = current.join("perro_core");
            if perro_core_path.exists() && perro_core_path.join("Cargo.toml").exists() {
                let perro_core_abs = dunce::canonicalize(&perro_core_path)
                    .map_err(|e| format!("Failed to canonicalize perro_core path: {}", e))?;

                let relative = calculate_relative_path(&scripts_cargo_path, &perro_core_abs)?;
                let path_str = relative.replace('\\', "/");
                return Ok(format!("perro_core = {{ path = \"{}\" }}", path_str));
            }
        }

        match current.parent() {
            Some(parent) => current = parent.to_path_buf(),
            None => break,
        }
    }

    // Fallback: try relative to executable
    if let Ok(exe) = std::env::current_exe() {
        if let Some(exe_dir) = exe.parent() {
            let mut current = exe_dir.to_path_buf();
            for _ in 0..10 {
                let perro_core_path = current.join("perro_core");
                if perro_core_path.exists() && perro_core_path.join("Cargo.toml").exists() {
                    let perro_core_abs = dunce::canonicalize(&perro_core_path)
                        .map_err(|e| format!("Failed to canonicalize perro_core path: {}", e))?;

                    let relative = calculate_relative_path(&scripts_cargo_path, &perro_core_abs)?;
                    let path_str = relative.replace('\\', "/");
                    return Ok(format!("perro_core = {{ path = \"{}\" }}", path_str));
                }

                match current.parent() {
                    Some(parent) => current = parent.to_path_buf(),
                    None => break,
                }
            }
        }
    }

    // Fallback: add two more ../ to the default
    Ok("perro_core = { path = \"../../../../perro_core\" }".to_string())
}

/// Calculate relative path from `from` to `to`
fn calculate_relative_path(from: &Path, to: &Path) -> Result<String, String> {
    let from_components: Vec<_> = from.components().collect();
    let to_components: Vec<_> = to.components().collect();

    // Find common prefix
    let common_len = from_components
        .iter()
        .zip(to_components.iter())
        .take_while(|(a, b)| a == b)
        .count();

    // Build relative path
    let mut result = PathBuf::new();

    // Add ".." for each component in `from` that's not common
    for _ in common_len..from_components.len() {
        result.push("..");
    }

    // Add remaining components from `to`
    for component in &to_components[common_len..] {
        result.push(component);
    }

    result
        .to_str()
        .ok_or_else(|| "Path contains invalid UTF-8".to_string())
        .map(|s| s.to_string())
}

fn is_valid_project_name(name: &str) -> bool {
    if name.is_empty() {
        return false;
    }

    let mut chars = name.chars();
    // First character must be letter or underscore
    match chars.next() {
        Some(c) if c.is_ascii_alphabetic() || c == '_' => {}
        _ => return false,
    }

    // Rest must be alphanumeric or underscore
    chars.all(|c| c.is_ascii_alphanumeric() || c == '_')
}

fn generate_project_toml(project_name: &str) -> String {
    format!(
        r#"[project]
name = "{}"
main_scene = "res://main.scn"
# Icon is optional - if not provided, build will skip icon embedding
icon = "res://icon.png"
version = "1.0.0"

[graphics]
# Virtual resolution (coordinate space). Window opens at this size.
virtual_width = 1920
virtual_height = 1080
# MSAA for smooth 3D edges: "off" (1x), "on" (4x)
msaa = "on"

[performance]
fps_cap = 300
xps = 60

[input]
# Input action mappings
# Format: action_name = ["InputSource1", "InputSource2", ...]
# Multiple inputs can map to the same action
# 
# Available input sources:
# - Keyboard: "Space", "Enter", "Escape", "KeyW", "KeyA", etc.
# - Arrow keys: "Up", "Down", "Left", "Right"
# - Modifiers: "Shift", "Control", "Alt", "Meta"
# - Mouse: "MouseLeft", "MouseRight", "MouseMiddle"
# - Scroll: "MouseWheelUp", "MouseWheelDown"
#
# Example actions:
jump = ["Space", "Up"]
move_forward = ["KeyW"]
move_backward = ["KeyS"]
move_left = ["KeyA"]
move_right = ["KeyD"]
"#,
        project_name
    )
}

fn generate_main_scn() -> String {
    r#"{
  "root_id": 0,
  "nodes": {
    "0": {
      "type": "Node2D",
      "base": { "type": "Node", "name": "World" }
    },
    "1": {
      "type": "Camera2D",
      "active": true,
      "base": {
        "type": "Node2D",
        "base": { "type": "Node", "name": "Camera", "parent": "0" }
      }
    }
  }
}
"#
    .to_string()
}

fn generate_gitignore() -> String {
    r#"# Ignore Perro build artifacts
builds/

/.perro/project/src/static_assets/
/.perro/project/embedded_assets/

/.perro/scripts/src/

/assets.brk

build.log

icon.ico

perro_engine.png
perro_engine.desktop

# Ignore profiling files
flamegraph.folded
flamegraph.svg

# Ignore target directories (should use workspace root target via CARGO_TARGET_DIR)
target/
/.perro/project/target/
/.perro/scripts/target/
"#
    .to_string()
}

fn generate_project_cargo_toml(project_name: &str, perro_core_dep: &str) -> String {
    format!(
        r#"[workspace]

[package]
name = "{}"
version = "0.1.0"
edition = "2024"
build = "build.rs"

[dependencies]
{}
scripts = {{ path = "../scripts" }}
uuid = {{ version = "1.4", features = ["serde", "v4"] }}
indexmap = {{ version = "1.9", features = ["serde"] }}
once_cell = "1.19"
phf = {{ version = "0.13.1", features = ["macros"] }}

[build-dependencies]
toml = "0.8"
embed-resource = "2.4"
image = "0.24"
ico = "0.3"
chrono = "0.4"
resvg = "0.44"

[[bin]]
name = "{}"
path = "src/main.rs"

[profile.release]
opt-level = 3
lto = "fat"
codegen-units = 1
panic = "abort"
debug = false
strip = "symbols"

[profile.release.package."*"]
opt-level = 3
debug = false
overflow-checks = false

[target.'cfg(windows)']
rustflags = ["-C", "link-args=/SUBSYSTEM:WINDOWS"]
"#,
        project_name, perro_core_dep, project_name
    )
}

fn generate_scripts_cargo_toml(perro_core_dep: &str) -> String {
    format!(
        r#"[workspace]

[package]
name = "scripts"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
{}
uuid = {{ version = "1.4", features = ["serde", "v4"] }}
indexmap = {{ version = "1.9", features = ["serde"] }}
serde = {{ version = "1.0", features = ["derive","rc"] }}
serde_json = "1.0"
rust_decimal = {{ version = "1.36", features = ["serde"] }}
num-bigint = {{ version = "0.4", features = ["serde"] }}
smallvec = "1.11"
once_cell = "1.19"
phf = {{ version = "0.13.1", features = ["macros"] }}
toml = "0.8"
regex = "1"

[profile.dev]
opt-level = 1
incremental = true
codegen-units = 256
lto = false
debug = false
strip = "none"
overflow-checks = false
panic = "abort"
"#,
        perro_core_dep
    )
}
