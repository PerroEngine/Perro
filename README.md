# ğŸ• Perro Game Engine

<div align="center">
  <img src="icon.png" alt="Perro Logo" width="200"/>
</div>

**Perro** is an experimental, open-source game engine written in **Rust**, designed as a modern alternative to engines like Unreal, Godot, and Unity.

**Version: 0.1.0 prerelease.** There is **no editor** right now â€” this is mainly a showcase of what exists so far. The **whole point** of the scripting system is that your scripts (Pup, and experimentally TypeScript/C#) **transpile to Rust** and interop directly with the engine core; that pipeline is where most of the work lives, and **bugs or rough edges can happen**. If you hit issues â€” wrong codegen, parse errors, or weird behavior â€” **please report them.** Contributions and experimentation are welcome.

It focuses on **performance, flexibility, and ease of use** with a unique scripting system that transpiles to Rust for native performance:

- ğŸ¶ **Pup DSL** â€“ a beginner-friendly, lightweight scripting language that compiles to Rust for native performance. Write your gameplay logic in Pup and get the speed of Rust.
- ğŸ¨ **FUR (Flexible UI Rules)** â€“ a declarative UI system with layouts, panels, and boxing for easy UI design.
- ğŸ“¦ **Type-Safe Transpilation** â€“ full type checking and casting during code generation. All scripts transpile to Rust under the hood.
- âš¡ **Optimized Release Builds** â€“ scripts and assets statically link into your final binary.
- ğŸ”— **Decoupled Signal System** â€“ global, name-based signals that completely decouple emitters from listeners. Use `on SIGNALNAME() {}` shorthand for automatic connections.

**ğŸ“š [Full Documentation â†’](https://perroengine.com/docs)**  
Scripting reference (node API, resources, types) is in the **[docs/](docs/)** folder: [PUP](docs/PUP.md), [TypeScript](docs/TYPESCRIPT.md) (experimental), [C#](docs/CSHARP.md) (experimental).

---

## ğŸš€ Quick Start

### Install Syntax Highlighting

First, install the Perro syntax highlighting extension for VS Code:

```bash
# From the repository root
code --install-extension .vscode-extensions/perro-syntax
```

This provides syntax highlighting for `.pup`, `.fur`, and `.scn` files.

### Create Your First Project

```bash
# Create a new project (defaults to workspace/projects/ProjectName)
cargo run -p perro_core -- new MyGame

# Or specify a custom path
cargo run -p perro_core -- new MyGame /path/to/project
```

This creates a new project structure with:
- `project.toml` - Project configuration
- `res/` - Resources folder (scenes, scripts, assets)
- `res/main.scn` - Default scene with a "World" Node2D and Camera
- `.perro/` - Build artifacts (generated by compiler)
- `.gitignore` - Ignores generated files

### Run Your Project

```bash
# Build scripts and run project in one command
cargo run -p perro_core -- --path /path/to/project --dev
```

The `--dev` command automatically:
1. Compiles `perro_dev` in release mode (only recompiles on engine changes - longer compile time)
2. Transpiles scripts (Pup â†’ Rust) - typically under 5 seconds
3. Compiles scripts into a DLL - only recompiles on Pup source changes
4. Runs the project - instant if no changes detected

**Smart Recompilation:**
- **No changes:** Instant run (no compilation needed)
- **Pup source changes:** Fast recompile (~1-5 seconds)
- **Engine changes:** Full recompile of `perro_dev` (longer, but only when needed)

---

## ğŸ¶ Pup DSL

**Pup** is Perro's built-in scripting language â€” simple, readable, and compiles to Rust.

### Script Definition

Scripts are defined with the `@script` directive followed by a name and the node type they extend:

<pre><code><span style="color: #E6A044">@script</span> <span style="color: #2EE68A">Player</span> <span style="color: #E66BB3">extends</span> <span style="color: #2EE68A">Sprite2D</span>
    <span style="color: #E66BB3">var</span> <span style="color: #D4D4D4">speed</span> = <span style="color: #D4B87A">7.5</span>

    <span style="color: #E6A044; font-weight: bold">on</span> <span style="color: #7FC3E8">init</span>() {
        <span style="color: #2EE68A">Console</span>.<span style="color: #47B0E6">print</span>(<span style="color: #D4B87A">"Player is ready!"</span>)
        <span style="color: #47B0E6">set_speed</span>(<span style="color: #D4B87A">2.1</span>)
    }

    <span style="color: #E66BB3">fn</span> <span style="color: #47B0E6">set_speed</span>(<span style="color: #D4D4D4">new_speed</span>: <span style="color: #2EE68A">float</span>) {
        <span style="color: #D4D4D4">speed</span> = <span style="color: #D4D4D4">new_speed</span>
    }

    <span style="color: #E6A044; font-weight: bold">on</span> <span style="color: #7FC3E8">update</span>() {
        <span style="color: #E66BB3">var</span> <span style="color: #D4D4D4">delta</span> = <span style="color: #2EE68A">Time</span>.<span style="color: #47B0E6">get_delta</span>()
        <span style="color: #E6A044">self</span>.<span style="color: #9DB4C4">transform</span>.<span style="color: #9DB4C4">position</span>.<span style="color: #9DB4C4">x</span> += <span style="color: #D4D4D4">speed</span> * <span style="color: #D4D4D4">delta</span>
    }
</code></pre>

**Function Syntax:**
- `on` - Used for **lifecycle methods** (`init`, `update`, `draw`, `fixed_update`) and **signal handlers** (auto-connection). Lifecycle methods cannot be called directly - they're hooks that the engine calls automatically.
- `fn` - Used for **regular methods** that you can call from your code.

### Accessing Nodes

Get child nodes using `self.get_node("name")`. This returns a node reference that you can use with both `.` (engine-level fields/functions) and `::` (custom script functions):

<pre><code><span style="color: #E6A044">@script</span> <span style="color: #2EE68A">Player</span> <span style="color: #E66BB3">extends</span> <span style="color: #2EE68A">Sprite2D</span>

<span style="color: #E6A044; font-weight: bold">on</span> <span style="color: #7FC3E8">init</span>() {
    <span style="color: #6A9955; font-style: italic">// Get a child node - returns a node reference</span>
    <span style="color: #E6A044">self</span>.<span style="color: #47B0E6">get_node</span>(<span style="color: #D4B87A">"Weapon"</span>).<span style="color: #9DB4C4">name</span> = <span style="color: #D4B87A">"Sword"</span>
    
    <span style="color: #6A9955; font-style: italic">// Store in a variable for reuse</span>
    <span style="color: #E66BB3">var</span> <span style="color: #D4D4D4">weapon</span> = <span style="color: #E6A044">self</span>.<span style="color: #47B0E6">get_node</span>(<span style="color: #D4B87A">"Weapon"</span>)
    
    <span style="color: #6A9955; font-style: italic">// Use . for engine-level fields and functions</span>
    <span style="color: #D4D4D4">weapon</span>.<span style="color: #9DB4C4">name</span> = <span style="color: #D4B87A">"Axe"</span>
    <span style="color: #D4D4D4">weapon</span>.<span style="color: #9DB4C4">transform</span>.<span style="color: #9DB4C4">position</span>.<span style="color: #9DB4C4">x</span> = <span style="color: #D4B87A">10.0</span>
    
    <span style="color: #6A9955; font-style: italic">// Use :: for script-level operations (non-concrete syntax)</span>
    <span style="color: #D4D4D4">weapon</span><span style="color: #E6A044">::</span><span style="color: #47B0E6">reload</span>()
    <span style="color: #D4D4D4">weapon</span><span style="color: #E6A044">::</span><span style="color: #D4D4D4">ammo</span> = <span style="color: #D4B87A">100</span>
    
    <span style="color: #6A9955; font-style: italic">// Chain node access</span>
    <span style="color: #E6A044">self</span>.<span style="color: #47B0E6">get_node</span>(<span style="color: #D4B87A">"Weapon"</span>).<span style="color: #47B0E6">get_node</span>(<span style="color: #D4B87A">"Scope"</span>).<span style="color: #9DB4C4">visible</span> = <span style="color: #D4D4D4">true</span>
}
</code></pre>

**Key Points:**
- **`.` (dot)** - Used for **concrete engine-level fields and functions** that nodes expose (like `transform`, `name`, `texture`, etc.). These are direct, in-place mutations or reads on the node itself.
- **`::` (double colon)** - Used for **non-concrete syntax** that the engine exposes - script-level operations that cross the script boundary. This allows you to differentiate between concrete operations and script-level operations.

**Why the distinction matters:**
- `self.name` vs `self::name` - Differentiates between engine field access and script variable access
- `self.transform` vs `transform` - Makes it clear when you're accessing the engine field vs a local variable
- `enemy.name` vs `enemy::name` - Same distinction for other node references

The `::` syntax is both a compiler hint (telling the transpiler this is a script-level operation) and a visual indicator (helping you see the difference between concrete engine operations and dynamic script operations).

### Signals & Event Handling

Perro uses a **global, decoupled signal system**. Signals are identified by name strings, and any script can listen for any signal without needing a reference to the emitter. This completely decouples signalers from listeners.

#### Signal Shorthand: `on SIGNALNAME() {}`

The easiest way to handle signals is using the `on` keyword shorthand. This automatically creates a function and connects it to the signal at script initialization. The `on` keyword is also used for lifecycle methods (`init`, `update`, `draw`, `fixed_update`), making it clear these are hooks that connect your script to the engine's lifecycle.

<pre><code><span style="color: #E6A044">@script</span> <span style="color: #2EE68A">GameManager</span> <span style="color: #E66BB3">extends</span> <span style="color: #2EE68A">Node</span>

<span style="color: #E66BB3">on</span> <span style="color: #47B0E6">start_Pressed</span>() {
    <span style="color: #2EE68A">Console</span>.<span style="color: #47B0E6">print</span>(<span style="color: #D4B87A">"Start button was pressed!"</span>)
    <span style="color: #6A9955; font-style: italic">// Start the game...</span>
}

<span style="color: #E66BB3">on</span> <span style="color: #47B0E6">pause_Pressed</span>() {
    <span style="color: #2EE68A">Console</span>.<span style="color: #47B0E6">print</span>(<span style="color: #D4B87A">"Game paused"</span>)
}
</code></pre>

The `on` syntax automatically:
- Connects the code inside to the signal matching the same name
- For lifecycle methods (`init`, `update`, `draw`, `fixed_update`), connects your script to the engine's lifecycle hooks (these cannot be called directly)

#### Manual Signal Connection

You can also manually connect signals using `Signal.connect()`. When connecting to script-level functions (non-concrete operations), use `::` to indicate it's a script boundary operation:

<pre><code><span style="color: #E6A044">@script</span> <span style="color: #2EE68A">Player</span> <span style="color: #E66BB3">extends</span> <span style="color: #2EE68A">Sprite2D</span>

<span style="color: #E66BB3">var</span> <span style="color: #D4D4D4">enemy</span>: <span style="color: #2EE68A">Node2D</span>
<span style="color: #E66BB3">var</span> <span style="color: #D4D4D4">bob</span>: <span style="color: #2EE68A">Sprite2D</span>

<span style="color: #E6A044; font-weight: bold">on</span> <span style="color: #7FC3E8">init</span>() {
    <span style="color: #6A9955; font-style: italic">// Connect to a signal on self (function name as string)</span>
    <span style="color: #2EE68A">Signal</span>.<span style="color: #47B0E6">connect</span>(<span style="color: #D4B87A">"player_Died"</span>, <span style="color: #47B0E6">on_player_died</span>)
    
    <span style="color: #6A9955; font-style: italic">// Connect to script-level functions on other nodes using ::</span>
    <span style="color: #2EE68A">Signal</span>.<span style="color: #47B0E6">connect</span>(<span style="color: #D4B87A">"enemy_Defeated"</span>, <span style="color: #D4D4D4">enemy</span><span style="color: #E6A044">::</span><span style="color: #47B0E6">on_enemy_defeated</span>)
    <span style="color: #2EE68A">Signal</span>.<span style="color: #47B0E6">connect</span>(<span style="color: #D4B87A">"bob_Pressed"</span>, <span style="color: #D4D4D4">bob</span><span style="color: #E6A044">::</span><span style="color: #47B0E6">on_bob_pressed</span>)
}

<span style="color: #E66BB3">fn</span> <span style="color: #47B0E6">on_player_died</span>() {
    <span style="color: #2EE68A">Console</span>.<span style="color: #47B0E6">print</span>(<span style="color: #D4B87A">"Player died!"</span>)
}
</code></pre>

**Why `::` for script-level operations?**
- `::` indicates **non-concrete syntax** that the engine exposes - script-level operations that cross the script boundary
- This allows you to differentiate between concrete engine operations (`.`) and dynamic script operations (`::`)
- Use `.` for concrete engine fields/functions (like `node.name`, `node.transform`) - direct, in-place operations
- Use `::` for script-level operations (like `node::name`, `node::custom_function()`) - dynamic calls across script boundaries
- The distinction helps both the compiler (knowing what type of operation to generate) and you (seeing the difference visually)

#### Decoupled Signal System Example

Here's a complete example showing how signals work across different scripts:

**FUR UI File (`res/ui.fur`):**
<pre><code>    <span style="color: #2EE68A">[Button</span> <span style="color: #7A9FC8">id</span>=<span style="color: #E6A044">start</span><span style="color: #2EE68A">]</span>
        Start Game
    <span style="color: #2EE68A">[/Button]</span>
</code></pre>

**Game Manager Script (`res/game_manager.pup`):**
<pre><code><span style="color: #E6A044">@script</span> <span style="color: #2EE68A">GameManager</span> <span style="color: #E66BB3">extends</span> <span style="color: #2EE68A">Node</span>

<span style="color: #E6A044; font-weight: bold">on</span> <span style="color: #7FC3E8">init</span>() {
    <span style="color: #2EE68A">Console</span>.<span style="color: #47B0E6">print</span>(<span style="color: #D4B87A">"Game manager ready, listening for start button..."</span>)
}

<span style="color: #6A9955; font-style: italic">// Listen for the start button signal (emitted automatically by the button)</span>
<span style="color: #E66BB3">on</span> <span style="color: #47B0E6">start_Pressed</span>() {
    <span style="color: #2EE68A">Console</span>.<span style="color: #47B0E6">print</span>(<span style="color: #D4B87A">"Starting the game!"</span>)
    <span style="color: #6A9955; font-style: italic">// Initialize game state, load level, etc.</span>
}
</code></pre>

**Key Points:**
- The button in FUR automatically emits `start_Pressed` when clicked (based on its `id`)
- The game manager doesn't need a reference to the button
- The game manager doesn't even need to be in the same scene
- Any script anywhere can listen for `start_Pressed` by name if connected
- The signal system is completely global and decoupled

This decoupling means you can:
- Have UI buttons that emit signals without any scripts attached
- Have game logic scripts that listen for signals without knowing where they come from
- Easily add new listeners or emitters without modifying existing code
- Test signals independently of their sources

---

## ğŸ¨ FUR (Flexible UI Rules)

**FUR** is Perro's declarative UI system for building layouts and UI panels.

### Basic UI

<pre><code>    <span style="color: #2EE68A">[Panel</span> <span style="color: #7A9FC8">bg</span>=<span style="color: #E6A044">sea-5</span> <span style="color: #7A9FC8">padding</span>=<span style="color: #E6A044">4</span><span style="color: #2EE68A">]</span>
        <span style="color: #2EE68A">[Text</span> <span style="color: #7A9FC8">font-weight</span>=<span style="color: #E6A044">bold</span> <span style="color: #7A9FC8">text-color</span>=<span style="color: #E6A044">white</span> <span style="color: #7A9FC8">text-size</span>=<span style="color: #E6A044">xl</span><span style="color: #2EE68A">]</span>
            Hello Perro!
        <span style="color: #2EE68A">[/Text]</span>
    <span style="color: #2EE68A">[/Panel]</span>
</code></pre>

### UI Composition with Includes

FUR supports powerful composition using `[Include]` to include other FUR files:

<pre><code>    <span style="color: #2EE68A">[Panel</span> <span style="color: #7A9FC8">bg</span>=<span style="color: #E6A044">dark-3</span><span style="color: #2EE68A">]</span>
        <span style="color: #2EE68A">[Include</span> <span style="color: #7A9FC8">path</span>=<span style="color: #D4B87A">"res://ui/header.fur"</span><span style="color: #2EE68A">/]</span>
        <span style="color: #2EE68A">[Include</span> <span style="color: #7A9FC8">path</span>=<span style="color: #D4B87A">"res://ui/menu.fur"</span><span style="color: #2EE68A">/]</span>
        <span style="color: #2EE68A">[Include</span> <span style="color: #7A9FC8">path</span>=<span style="color: #D4B87A">"res://ui/footer.fur"</span><span style="color: #2EE68A">/]</span>
    <span style="color: #2EE68A">[/Panel]</span>
</code></pre>

This allows you to:
- Break UI into reusable components
- Compose complex UIs from smaller pieces
- Maintain consistent styling across your application
- Easily swap out UI sections

**Current Features:**
- Layouts and child layouts
- Panels and boxing
- Styling and padding
- UI composition with includes

See `perro_editor/res/fur` for real examples of FUR in use.

---

## ğŸ‘©â€ğŸ’» Development

### Development Workflow

**Quick Dev Command (Build + Run):**

```bash
# Build scripts and run project in one command
cargo run -p perro_core -- --path /path/to/project --dev
```

The `--dev` command automatically:
1. Compiles `perro_dev` in release mode (only recompiles on engine changes - longer compile time)
2. Transpiles scripts (Pup â†’ Rust) - typically under 5 seconds
3. Compiles scripts into a DLL - only recompiles on Pup source changes
4. Runs the project - instant if no changes detected

**Smart Recompilation:**
- **No changes:** Instant run (no compilation needed)
- **Pup source changes:** Fast recompile (~1-5 seconds)
- **Engine changes:** Full recompile of `perro_dev` (longer, but only when needed)

**Manual Workflow (if you prefer more control):**

**Build Scripts Only:**

```bash
# Compile scripts only (for testing changes)
cargo run -p perro_core -- --path /path/to/project --scripts
```

**Iteration Cycle:**

- Make changes to scripts in `res/*`
- Re-run `--dev` - it will only recompile what changed
- Fast iteration cycle (instant if no changes, ~1â€“5s for script changes)

### âš ï¸ Source Mode Performance Considerations

When building games from source, the runtime (`perro_dev`) runs in **debug mode** by default, which means it's unoptimized. This is fine for development, but if you need better performance:

**For better performance, run in release mode:**

```bash
# Run perro_dev in release mode for better performance
cargo run --release -p perro_dev -- --path /path/to/project
```

**If you're making engine changes:**
- Rebuild the runtime in release mode when you make engine changes:
  ```bash
  cargo build --release -p perro_dev
  ```
- Then run the release binary:
  ```bash
  ./target/release/perro_dev.exe --path /path/to/project
  ```

**If you're NOT making engine changes:**
- Precompile the runtime in release mode once:
  ```bash
  cargo build --release -p perro_dev
  ```
- Then use the release binary for all your game development:
  ```bash
  ./target/release/PerroDevRuntime.exe --path /path/to/project
  ```
- If no path is provided, the release binary must be in the same directory as a project folder with a valid `project.toml` in it.

**Why?** The source mode workflow (`cargo run`) is optimized for engine development, not heavy game operations. The engine (`perro_core`) is primarily designed for compiling scripts and building projects, not for active development. For better performance during game development, use `--release` flag or a pre-built release binary.

### Release Build

**Build Final Release:**

```bash
# Build complete release (compiles everything statically and strips out console logs)
cargo run -p perro_core -- --path /path/to/project --project
```

**Build Verbose Release (with console window):**

```bash
# Build release with verbose output and visible console
cargo run -p perro_core -- --path /path/to/project --project --verbose
```

This:
- Transpiles all scripts â†’ Rust
- Compiles scripts + project into a single binary
- Embeds assets and scripts statically
- Produces an optimized, distributable executable
- **Verbose mode:** Removes Windows subsystem flag so console is visible and makes console logs visible (useful for debugging)

**Result:** A single executable with no external dependencies or DLLs.

### Making Your First Game

1. **Create a new project** using the CLI (see above)
2. **Write scripts** in Pup in `res/` folder
3. **Design scenes** by editing `res/*.scn` JSON files
4. **Design UI** with FUR files in `res/`
5. **Follow the development workflow** above to test and iterate
6. **Build release** when ready to distribute

---

## ğŸ”„ Dev vs Release

### Dev Mode (DLL Loading)

- Scripts are transpiled to Rust, compiled into a **DLL**
- Engine loads the DLL at runtime
- Load files from disk
- Make changes â†’ recompile (~1â€“3s) â†’ restart to see updates

### Release Mode (Static Linking)

- All scripts transpile â†’ Rust
- Statically linked into final binary
- **Result:**
  - Single executable (no DLLs, no source included)
  - Optimized machine code from LLVM
  - Scenes, FUR files, images, etc. are all statically embedded
  - Your source scripts are protected

---

## ğŸ› ï¸ For Engine Contributors & Development

This repository contains the **Perro engine source code**. To build and work on the engine itself:

### Prerequisites

- **Rust 1.92.0 or later** (GNU toolchain required - this is what ships with the editor binary for compilation)
- **Cargo**

**âš ï¸ Linux System Dependencies**

On Linux, you may need to install system dependencies before building. If you encounter errors about missing libraries (such as `libdbus-1-dev` or `libudev-dev`), run:

```bash
# Install all dependencies (recommended)
./install-deps.sh

# Or install essential packages individually
sudo apt install -y libdbus-1-dev libudev-dev pkg-config
```

The `install-deps.sh` script will install all required dependencies for your distribution (Ubuntu/Debian, Fedora/RHEL, or Arch Linux). If you encounter GPG errors with `apt update`, the script will continue anyway and attempt to install the packages.

**Common build errors:**
- `libdbus-sys` build failure â†’ Install `libdbus-1-dev` and `pkg-config`
- `hidapi` build failure (Unable to find libudev) â†’ Install `libudev-dev`
- Missing graphics libraries â†’ The install script includes all necessary graphics dependencies

**âš ï¸ Important: GNU Toolchain Required on Windows**

Perro requires the **GNU toolchain**. Here's how to install and set it up:

```bash
# Install the GNU toolchain (1.92.0 or later)
rustup toolchain install stable-x86_64-pc-windows-gnu

# Set GNU toolchain as default
rustup default stable-x86_64-pc-windows-gnu

# Verify you're using GNU toolchain
rustc --version
# Should show: rustc 1.92.0 (or later) ... (x86_64-pc-windows-gnu)

# Or verify with rustup
rustup show
# Should show: default toolchain: stable-x86_64-pc-windows-gnu
```

**If you already have Rust installed with MSVC:**

```bash
# Install GNU toolchain for 1.92.0
rustup toolchain install 1.92.0-x86_64-pc-windows-gnu

# Set it as default
rustup default 1.92.0-x86_64-pc-windows-gnu

# Verify
rustc --version
```

**Updating an existing GNU toolchain:**

```bash
# Update to latest stable GNU toolchain
rustup update stable-x86_64-pc-windows-gnu

# Or update your default (if already set to GNU)
rustup update stable
```

### Repository Structure

```
perro/
â”œâ”€â”€ perro_core/          # Core engine (structs, scene, render graph)
â”œâ”€â”€ perro_dev/           # Dev wrapper binary (loads DLLs, runs projects with --path)
â”œâ”€â”€ perro_editor/        # Editor game project
â”‚   â”œâ”€â”€ .perro/
â”‚   â”‚   â”œâ”€â”€ project/     # Editor project crate (final exported binary in --project mode)
â”‚   â”‚   â””â”€â”€ scripts/     # Editor scripts crate (contains transpiled rust + builds DLL)
â”‚   â””â”€â”€ res/             # Resources (FUR files, scenes, assets, scripts)
â””â”€â”€ projects/            # Example game projects
```

### Building & Running

**Open the Editor in Dev Mode:**

```bash
# âš ï¸ You must specify -- --path PATH when running perro_dev
cargo run -p perro_dev -- --path /path/to/project

# For better performance during development:
cargo run --release -p perro_dev -- --path /path/to/project
```

**Build the Core Alone:**

```bash
cargo build -p perro_core
```

All projects share a build cache (the main workspace target/ in source mode), so the core only compiles once.

### Toolchain & Versioning

The editors are pinned to specific versions of the toolchain, (eg. 1.0 => 1.92.0), toolchains will NOT always be updated each engine update, as to not clog the end user's system with multiple toolchains they don't need. (1.0 and 1.1 could support the same toolchain, even if users update it only is installed once)

**Current Requirements:**
- **Rust 1.92.0 or later** (required for wgpu 28.0.0)
- Default toolchain version: **1.92.0**

**Project Compatibility:**

- Old projects use their original editor version by default
- The Project Manager auto-updates to the latest version
- You can manually upgrade a project to a newer editor version if desired
- Older editor versions remain available for projects that haven't upgraded

### Stabilized Features

- âœ… Pup scripting system (Pup -> Rust pipeline)
- âœ… Type checking and casting during Rust codegen
- âœ… DLL loading & dynamic script loading
- âœ… Static linking of scripts and assets during release
- âœ… FUR layouts, panels, child layouts, and boxing
- âœ… Global decoupled signal system with 500ns dispatch

### In Progress / Planned

- ğŸ”„ Pup DSL expansion (control flow, standard library)
- ğŸ”„ FUR runtime editing & editor viewer
- ğŸ“‹ Scene editor
- ğŸ“‹ Asset pipeline

### Experimental Features

- ğŸ§ª **C# & TypeScript Support** â€“ Experimental transpiler support for C# and TypeScript via Tree Sitter. These languages would be great additions once the transpiler stabilizes, but are currently experimental and not all AST bindings and behavior are implemented yet.

---

## ğŸ¤ Contributing

Contributions are welcome! You can work on:

- **Engine** â€“ `perro_core` (rendering, scene, runtime)
- **Editor** â€“ Edit the source code and UI of the editor at `perro_editor/res`
- **Scripting** â€“ Pup DSL expansion, transpiler improvements, other language support as needed
- **Tooling** â€“ build system, asset pipeline

See [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

---

## ğŸ’œ Support Perro

Your support helps us continue developing Perro and making it accessible to everyone. With enough funding, donations can enable **full-time development** on Perro, dramatically accelerating progress and bringing features to production faster.

Donations help fund:

- ğŸ’¼ **Full-Time Development** â€“ Your contributions can enable dedicated, full-time work on Perro, allowing for faster feature development, more consistent updates, and quicker bug fixes
- ğŸš€ **Accelerated Development** â€“ More time for core features like the scene editor, asset pipeline, and expanded Pup DSL capabilities
- ğŸ› ï¸ **Better Tooling & Infrastructure** â€“ Improved development tools, CI/CD pipelines, documentation, and testing infrastructure
- ğŸ“š **Enhanced Documentation** â€“ Comprehensive tutorials, example projects, and detailed guides
- ğŸ› **Bug Fixes & Stability** â€“ More time fixing bugs, improving performance, and ensuring Perro runs smoothly across platforms
- ğŸŒ **Community Growth** â€“ Supporting forums, community events, and developer outreach
- âš¡ **Performance & Optimization** â€“ Investing in profiling tools and optimization work

**Ways to Support:**

- [â˜• Support on Ko-fi](https://ko-fi.com/perroengine)
- [ğŸŒ Support Directly](https://perroengine.com/sponsor)

Every contribution, no matter the size, makes a difference! Thank you for supporting open-source game development! ğŸ®

---

## ğŸ“œ License

Perro is licensed under the **Apache 2.0 License**. See [LICENSE](LICENSE) for details.

---

## ğŸ¾ Why "Perro"?

Every developer needs a loyal partner, just like a dog â€” and that's what Perro means in Spanish.
