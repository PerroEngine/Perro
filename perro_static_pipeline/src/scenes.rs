use crate::{StaticPipelineError, res_dir, static_dir};
use perro_io::walkdir::walk_dir;
use perro_scene::{Parser, RuntimeNodeData, RuntimeValue};
use std::{collections::HashMap, fmt::Write as _, fs, path::Path};

pub fn generate_static_scenes(project_root: &Path) -> Result<(), StaticPipelineError> {
    let res_dir = res_dir(project_root);
    let static_dir = static_dir(project_root);
    fs::create_dir_all(&static_dir)?;

    let mut scene_paths = Vec::<String>::new();
    let mut scene_defs = String::new();
    let mut any_uses_empty_keys = false;
    let mut any_uses_empty_fields = false;

    if res_dir.exists() {
        walk_dir(&res_dir, &mut |path| {
            if path.extension().and_then(|e| e.to_str()) != Some("scn") {
                return Ok(());
            }
            let rel = path.strip_prefix(&res_dir).unwrap().to_string_lossy().replace('\\', "/");
            let res_path = format!("res://{rel}");
            let src = fs::read_to_string(path)?;
            let parsed = std::panic::catch_unwind(|| Parser::new(&src).parse_scene())
                .map_err(|_| std::io::Error::other(format!("failed to parse scene: {res_path}")))?;
            let emitted = emit_static_scene_const(&res_path, &parsed)
                .map_err(|err| std::io::Error::other(err.to_string()))?;
            scene_defs.push_str(&emitted.code);
            any_uses_empty_keys |= emitted.uses_empty_keys;
            any_uses_empty_fields |= emitted.uses_empty_fields;
            scene_paths.push(res_path);
            Ok(())
        })?;
    }

    scene_paths.sort();
    let mut lookup = String::new();
    lookup.push_str("pub fn lookup_scene(path: &str) -> Option<&'static StaticScene> {\n");
    lookup.push_str("    match path {\n");
    for p in &scene_paths {
        let id = sanitize_ident(p);
        let _ = writeln!(lookup, "        \"{}\" => Some(&SCENE_{}),", escape_str(p), id);
    }
    lookup.push_str("        _ => None,\n");
    lookup.push_str("    }\n");
    lookup.push_str("}\n");

    let mut shared_consts = String::new();
    if any_uses_empty_keys {
        shared_consts.push_str("const EMPTY_SCENE_KEYS: &[StaticSceneKey] = &[];\n");
    }
    if any_uses_empty_fields {
        shared_consts.push_str("const EMPTY_SCENE_FIELDS: &[(&str, StaticSceneValue)] = &[];\n");
    }
    if !shared_consts.is_empty() {
        shared_consts.push('\n');
    }

    let scenes_src = format!(
        "// Auto-generated by Perro Static Pipeline. Do not edit.\n\
use perro_scene::{{StaticNodeData, StaticNodeEntry, StaticNodeType, StaticScene, StaticSceneKey, StaticSceneValue}};\n\n\
{shared_consts}\
{scene_defs}\n\
{lookup}",
        shared_consts = shared_consts
    );
    fs::write(static_dir.join("scenes.rs"), scenes_src)?;
    Ok(())
}

struct EmittedScene {
    code: String,
    uses_empty_keys: bool,
    uses_empty_fields: bool,
}

fn emit_static_scene_const(
    path: &str,
    scene: &perro_scene::RuntimeScene,
) -> Result<EmittedScene, StaticPipelineError> {
    let scene_ident = sanitize_ident(path);
    let mut out = String::new();
    let mut counter = 0usize;
    let mut node_entries = String::new();
    let mut uses_empty_keys = false;
    let mut uses_empty_fields = false;
    let mut children_by_parent: HashMap<&str, Vec<usize>> = HashMap::new();
    for (child_index, node) in scene.nodes.iter().enumerate() {
        if let Some(parent) = &node.parent {
            children_by_parent
                .entry(parent.as_str())
                .or_default()
                .push(child_index);
        }
    }

    for (index, node) in scene.nodes.iter().enumerate() {
        let children_ref = if let Some(children) = children_by_parent.get(node.key.as_str()) {
            if children.is_empty() {
                uses_empty_keys = true;
                "EMPTY_SCENE_KEYS".to_string()
            } else {
                let children_name = format!("CHILDREN_{}_{}", scene_ident, index);
                let _ = writeln!(out, "const {children_name}: &[StaticSceneKey] = &[");
                for &child_index in children {
                    let child_key = &scene.nodes[child_index].key;
                    let _ = writeln!(out, "    StaticSceneKey(\"{}\"),", escape_str(child_key));
                }
                out.push_str("];\n");
                children_name
            }
        } else {
            uses_empty_keys = true;
            "EMPTY_SCENE_KEYS".to_string()
        };

        let data_const = emit_node_data_consts(
            &mut out,
            &scene_ident,
            &node.data,
            &mut counter,
            &mut uses_empty_fields,
        )?;
        node_entries.push_str(&format!(
            "    StaticNodeEntry {{ key: StaticSceneKey(\"{key}\"), name: {name}, children: {children}, parent: {parent}, script: {script}, data: {data} }},\n",
            key = escape_str(&node.key),
            name = opt_static_str(&node.name),
            children = children_ref,
            parent = match &node.parent {
                Some(p) => format!("Some(StaticSceneKey(\"{}\"))", escape_str(p)),
                None => "None".to_string(),
            },
            script = opt_static_str(&node.script),
            data = data_const,
        ));
    }

    out.push_str(&format!(
        "const NODES_{id}: &[StaticNodeEntry] = &[\n{entries}];\n\n",
        id = scene_ident,
        entries = node_entries
    ));
    out.push_str(&format!(
        "pub static SCENE_{id}: StaticScene = StaticScene {{ nodes: NODES_{id}, root: {root} }};\n\n",
        id = scene_ident,
        root = match &scene.root {
            Some(r) => format!("Some(StaticSceneKey(\"{}\"))", escape_str(r)),
            None => "None".to_string(),
        }
    ));

    Ok(EmittedScene {
        code: out,
        uses_empty_keys,
        uses_empty_fields,
    })
}

fn emit_node_data_consts(
    out: &mut String,
    scene_ident: &str,
    data: &RuntimeNodeData,
    counter: &mut usize,
    uses_empty_fields: &mut bool,
) -> Result<String, StaticPipelineError> {
    let idx = *counter;
    *counter += 1;
    let data_name = format!("DATA_{}_{}", scene_ident, idx);
    let ty = emit_static_node_type(&data.ty)?;
    let fields_ref = if data.fields.is_empty() {
        *uses_empty_fields = true;
        "EMPTY_SCENE_FIELDS".to_string()
    } else {
        let fields_name = format!("FIELDS_{}_{}", scene_ident, idx);
        let mut nested_consts = String::new();
        let mut field_entries = String::new();
        for (name, value) in &data.fields {
            let emitted = emit_value_with_consts(&mut nested_consts, scene_ident, value, counter);
            let _ = writeln!(
                field_entries,
                "    (\"{}\", {}),",
                escape_str(name),
                emitted
            );
        }
        out.push_str(&nested_consts);
        let _ = writeln!(out, "const {fields_name}: &[(&str, StaticSceneValue)] = &[");
        out.push_str(&field_entries);
        out.push_str("];\n");
        fields_name
    };

    let base_ref = if let Some(base) = &data.base {
        let base_name = emit_node_data_consts(out, scene_ident, base, counter, uses_empty_fields)?;
        format!("Some(&{base_name})")
    } else {
        "None".to_string()
    };

    let _ = writeln!(
        out,
        "const {data_name}: StaticNodeData = StaticNodeData {{ ty: {ty}, fields: {fields_ref}, base: {base_ref} }};"
    );
    Ok(data_name)
}

fn emit_static_node_type(ty: &str) -> Result<&'static str, StaticPipelineError> {
    match ty {
        "Node" => Ok("StaticNodeType::Node"),
        "Node2D" => Ok("StaticNodeType::Node2D"),
        "Sprite2D" => Ok("StaticNodeType::Sprite2D"),
        "Camera2D" => Ok("StaticNodeType::Camera2D"),
        "Node3D" => Ok("StaticNodeType::Node3D"),
        "MeshInstance3D" => Ok("StaticNodeType::MeshInstance3D"),
        "Camera3D" => Ok("StaticNodeType::Camera3D"),
        "AmbientLight3D" => Ok("StaticNodeType::AmbientLight3D"),
        "RayLight3D" => Ok("StaticNodeType::RayLight3D"),
        "PointLight3D" => Ok("StaticNodeType::PointLight3D"),
        "SpotLight3D" => Ok("StaticNodeType::SpotLight3D"),
        _ => Err(StaticPipelineError::SceneParse(format!(
            "unsupported static node type `{ty}`"
        ))),
    }
}

fn emit_value_with_consts(
    out: &mut String,
    scene_ident: &str,
    value: &RuntimeValue,
    counter: &mut usize,
) -> String {
    match value {
        RuntimeValue::Bool(v) => format!("StaticSceneValue::Bool({v})"),
        RuntimeValue::I32(v) => format!("StaticSceneValue::I32({v})"),
        RuntimeValue::F32(v) => format!("StaticSceneValue::F32({v:?})"),
        RuntimeValue::Vec2 { x, y } => {
            format!("StaticSceneValue::Vec2 {{ x: {x:?}, y: {y:?} }}")
        }
        RuntimeValue::Vec3 { x, y, z } => {
            format!("StaticSceneValue::Vec3 {{ x: {x:?}, y: {y:?}, z: {z:?} }}")
        }
        RuntimeValue::Vec4 { x, y, z, w } => format!(
            "StaticSceneValue::Vec4 {{ x: {x:?}, y: {y:?}, z: {z:?}, w: {w:?} }}"
        ),
        RuntimeValue::Str(s) => format!("StaticSceneValue::Str(\"{}\")", escape_str(s)),
        RuntimeValue::Key(s) => {
            format!("StaticSceneValue::Key(StaticSceneKey(\"{}\"))", escape_str(s))
        }
        RuntimeValue::Object(entries) => {
            let idx = *counter;
            *counter += 1;
            let object_name = format!("OBJECT_{}_{}", scene_ident, idx);
            let mut nested_consts = String::new();
            let mut object_entries = String::new();
            for (name, value) in entries {
                let nested = emit_value_with_consts(&mut nested_consts, scene_ident, value, counter);
                let _ = writeln!(object_entries, "    (\"{}\", {}),", escape_str(name), nested);
            }
            out.push_str(&nested_consts);
            let _ = writeln!(out, "const {object_name}: &[(&str, StaticSceneValue)] = &[");
            out.push_str(&object_entries);
            out.push_str("];\n");
            format!("StaticSceneValue::Object({object_name})")
        }
    }
}

fn escape_str(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}

fn opt_static_str(v: &Option<String>) -> String {
    match v {
        Some(s) => format!("Some(\"{}\")", escape_str(s)),
        None => "None".to_string(),
    }
}

fn sanitize_ident(path: &str) -> String {
    let mut out = String::new();
    for c in path.chars() {
        if c.is_ascii_alphanumeric() {
            out.push(c.to_ascii_uppercase());
        } else {
            out.push('_');
        }
    }
    out
}
