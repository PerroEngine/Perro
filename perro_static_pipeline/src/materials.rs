use crate::{StaticPipelineError, res_dir, static_dir};
use perro_io::walkdir::walk_dir;
use perro_scene::{Parser, RuntimeValue};
use std::{collections::HashMap, fmt::Write as _, fs, io, path::Path};

pub fn generate_static_materials(project_root: &Path) -> Result<(), StaticPipelineError> {
    let res_dir = res_dir(project_root);
    let static_dir = static_dir(project_root);
    fs::create_dir_all(&static_dir)?;

    let mut materials: Vec<(String, MaterialLiteral)> = Vec::new();
    if res_dir.exists() {
        walk_dir(&res_dir, &mut |path| {
            let rel = path.strip_prefix(&res_dir).unwrap().to_string_lossy().replace('\\', "/");
            let res_path = format!("res://{rel}");
            match path.extension().and_then(|e| e.to_str()) {
                Some("pmat") => {
                    let src = fs::read_to_string(path)?;
                    let parsed = std::panic::catch_unwind(|| Parser::new(&src).parse_value_literal())
                        .map_err(|_| {
                            std::io::Error::other(format!("failed to parse material: {res_path}"))
                        })?;
                    let material = material_from_runtime_value(&parsed).ok_or_else(|| {
                        std::io::Error::other(format!(
                            "material `{res_path}` must be an object with at least one valid field"
                        ))
                    })?;
                    materials.push((res_path, material));
                }
                Some("glb") | Some("gltf") => {
                    let mut gltf_materials = materials_from_gltf_file(path, &res_path)?;
                    materials.append(&mut gltf_materials);
                }
                _ => {}
            }
            Ok(())
        })?;
    }

    materials.sort_by(|a, b| a.0.cmp(&b.0));

    let mut unique_materials = Vec::<MaterialLiteral>::new();
    let mut unique_by_key = HashMap::<MaterialKey, usize>::new();
    let mut material_refs = Vec::<(String, usize)>::with_capacity(materials.len());
    for (path, material) in materials {
        let key = MaterialKey::from(material);
        let index = if let Some(existing) = unique_by_key.get(&key).copied() {
            existing
        } else {
            let idx = unique_materials.len();
            unique_materials.push(material);
            unique_by_key.insert(key, idx);
            idx
        };
        material_refs.push((path, index));
    }

    let mut out = String::new();
    out.push_str("// Auto-generated by Perro Static Pipeline. Do not edit.\n");
    out.push_str("use perro_render_bridge::Material3D;\n\n");
    for (index, material) in unique_materials.iter().enumerate() {
        let const_name = format!("MATERIAL_{}", index);
        let _ = writeln!(
            out,
            "static {const_name}: Material3D = Material3D {{ base_color_factor: [{:.6}, {:.6}, {:.6}, {:.6}], roughness_factor: {:.6}, metallic_factor: {:.6}, occlusion_strength: {:.6}, emissive_factor: [{:.6}, {:.6}, {:.6}], alpha_mode: {}, alpha_cutoff: {:.6}, double_sided: {}, normal_scale: {:.6}, base_color_texture: {}, metallic_roughness_texture: {}, normal_texture: {}, occlusion_texture: {}, emissive_texture: {} }};",
            material.base_color_factor[0],
            material.base_color_factor[1],
            material.base_color_factor[2],
            material.base_color_factor[3],
            material.roughness_factor,
            material.metallic_factor,
            material.occlusion_strength,
            material.emissive_factor[0],
            material.emissive_factor[1],
            material.emissive_factor[2],
            material.alpha_mode,
            material.alpha_cutoff,
            if material.double_sided { "true" } else { "false" },
            material.normal_scale,
            material.base_color_texture,
            material.metallic_roughness_texture,
            material.normal_texture,
            material.occlusion_texture,
            material.emissive_texture
        );
    }
    out.push('\n');
    out.push_str("pub fn lookup_material(path: &str) -> Option<&'static Material3D> {\n");
    out.push_str("    match path {\n");
    for (path, index) in &material_refs {
        let _ = writeln!(
            out,
            "        \"{}\" => Some(&MATERIAL_{}),",
            escape_str(path),
            index
        );
    }
    out.push_str("        _ => None,\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    fs::write(static_dir.join("materials.rs"), out)?;
    Ok(())
}

#[derive(Clone, Copy)]
struct MaterialLiteral {
    base_color_factor: [f32; 4],
    roughness_factor: f32,
    metallic_factor: f32,
    occlusion_strength: f32,
    emissive_factor: [f32; 3],
    alpha_mode: u32,
    alpha_cutoff: f32,
    double_sided: bool,
    normal_scale: f32,
    base_color_texture: u32,
    metallic_roughness_texture: u32,
    normal_texture: u32,
    occlusion_texture: u32,
    emissive_texture: u32,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
struct MaterialKey {
    base_color_factor: [u32; 4],
    roughness_factor: u32,
    metallic_factor: u32,
    occlusion_strength: u32,
    emissive_factor: [u32; 3],
    alpha_mode: u32,
    alpha_cutoff: u32,
    double_sided: bool,
    normal_scale: u32,
    base_color_texture: u32,
    metallic_roughness_texture: u32,
    normal_texture: u32,
    occlusion_texture: u32,
    emissive_texture: u32,
}

impl From<MaterialLiteral> for MaterialKey {
    fn from(value: MaterialLiteral) -> Self {
        Self {
            base_color_factor: [
                value.base_color_factor[0].to_bits(),
                value.base_color_factor[1].to_bits(),
                value.base_color_factor[2].to_bits(),
                value.base_color_factor[3].to_bits(),
            ],
            roughness_factor: value.roughness_factor.to_bits(),
            metallic_factor: value.metallic_factor.to_bits(),
            occlusion_strength: value.occlusion_strength.to_bits(),
            emissive_factor: [
                value.emissive_factor[0].to_bits(),
                value.emissive_factor[1].to_bits(),
                value.emissive_factor[2].to_bits(),
            ],
            alpha_mode: value.alpha_mode,
            alpha_cutoff: value.alpha_cutoff.to_bits(),
            double_sided: value.double_sided,
            normal_scale: value.normal_scale.to_bits(),
            base_color_texture: value.base_color_texture,
            metallic_roughness_texture: value.metallic_roughness_texture,
            normal_texture: value.normal_texture,
            occlusion_texture: value.occlusion_texture,
            emissive_texture: value.emissive_texture,
        }
    }
}

fn material_from_runtime_value(value: &RuntimeValue) -> Option<MaterialLiteral> {
    let RuntimeValue::Object(entries) = value else {
        return None;
    };
    let mut out = MaterialLiteral {
        base_color_factor: [0.85, 0.85, 0.85, 1.0],
        roughness_factor: 0.5,
        metallic_factor: 0.0,
        occlusion_strength: 1.0,
        emissive_factor: [0.0, 0.0, 0.0],
        alpha_mode: 0,
        alpha_cutoff: 0.5,
        double_sided: false,
        normal_scale: 1.0,
        base_color_texture: u32::MAX,
        metallic_roughness_texture: u32::MAX,
        normal_texture: u32::MAX,
        occlusion_texture: u32::MAX,
        emissive_texture: u32::MAX,
    };
    let mut any = false;
    apply_runtime_material_entries(entries, &mut out, &mut any);
    any.then_some(out)
}

fn apply_runtime_material_entries(
    entries: &[(String, RuntimeValue)],
    out: &mut MaterialLiteral,
    any: &mut bool,
) {
    for (name, value) in entries {
        match name.as_str() {
            "roughnessFactor" => {
                if let Some(v) = runtime_as_f32(value) {
                    out.roughness_factor = v;
                    *any = true;
                }
            }
            "metallicFactor" => {
                if let Some(v) = runtime_as_f32(value) {
                    out.metallic_factor = v;
                    *any = true;
                }
            }
            "occlusionStrength" => {
                if let Some(v) = runtime_as_f32(value) {
                    out.occlusion_strength = v;
                    *any = true;
                }
            }
            "emissiveFactor" => {
                if let Some(v) = runtime_as_color4(value) {
                    out.emissive_factor = [v[0], v[1], v[2]];
                    *any = true;
                }
            }
            "baseColorFactor" => {
                if let Some(color) = runtime_as_color4(value) {
                    out.base_color_factor = color;
                    *any = true;
                }
            }
            "normalScale" => {
                if let Some(v) = runtime_as_f32(value) {
                    out.normal_scale = v;
                    *any = true;
                }
            }
            "alphaCutoff" => {
                if let Some(v) = runtime_as_f32(value) {
                    out.alpha_cutoff = v;
                    *any = true;
                }
            }
            "alphaMode" => {
                if let Some(mode) = runtime_as_alpha_mode(value) {
                    out.alpha_mode = mode;
                    *any = true;
                }
            }
            "doubleSided" => {
                if let Some(v) = runtime_as_bool(value) {
                    out.double_sided = v;
                    *any = true;
                }
            }
            "baseColorTexture" => {
                if let Some(index) = runtime_as_texture_index(value) {
                    out.base_color_texture = index;
                    *any = true;
                }
            }
            "metallicRoughnessTexture" => {
                if let Some(index) = runtime_as_texture_index(value) {
                    out.metallic_roughness_texture = index;
                    *any = true;
                }
            }
            "normalTexture" => {
                if let Some(index) = runtime_as_texture_index(value) {
                    out.normal_texture = index;
                    *any = true;
                }
            }
            "occlusionTexture" => {
                if let Some(index) = runtime_as_texture_index(value) {
                    out.occlusion_texture = index;
                    *any = true;
                }
            }
            "emissiveTexture" => {
                if let Some(index) = runtime_as_texture_index(value) {
                    out.emissive_texture = index;
                    *any = true;
                }
            }
            "pbrMetallicRoughness" => {
                if let RuntimeValue::Object(inner) = value {
                    apply_runtime_material_entries(inner, out, any);
                }
            }
            _ => {}
        }
    }
}

fn runtime_as_f32(value: &RuntimeValue) -> Option<f32> {
    match value {
        RuntimeValue::F32(v) => Some(*v),
        RuntimeValue::I32(v) => Some(*v as f32),
        _ => None,
    }
}

fn runtime_as_bool(value: &RuntimeValue) -> Option<bool> {
    match value {
        RuntimeValue::Bool(v) => Some(*v),
        _ => None,
    }
}

fn runtime_as_texture_index(value: &RuntimeValue) -> Option<u32> {
    match value {
        RuntimeValue::Object(entries) => entries.iter().find_map(|(name, inner)| {
            if name != "index" {
                return None;
            }
            match inner {
                RuntimeValue::I32(v) if *v >= 0 => Some(*v as u32),
                _ => None,
            }
        }),
        _ => None,
    }
}

fn runtime_as_alpha_mode(value: &RuntimeValue) -> Option<u32> {
    match value {
        RuntimeValue::Str(s) => match s.as_str() {
            "OPAQUE" => Some(0),
            "MASK" => Some(1),
            "BLEND" => Some(2),
            _ => None,
        },
        RuntimeValue::I32(v) if (0..=2).contains(v) => Some(*v as u32),
        _ => None,
    }
}

fn runtime_as_color4(value: &RuntimeValue) -> Option<[f32; 4]> {
    match value {
        RuntimeValue::Vec4 { x, y, z, w } => Some([*x, *y, *z, *w]),
        RuntimeValue::Vec3 { x, y, z } => Some([*x, *y, *z, 1.0]),
        _ => None,
    }
}

fn escape_str(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}

fn materials_from_gltf_file(path: &Path, res_path: &str) -> io::Result<Vec<(String, MaterialLiteral)>> {
    let (doc, _buffers, _images) = gltf::import(path).map_err(|err| {
        io::Error::other(format!("failed to import model `{res_path}` for materials: {err}"))
    })?;

    let mut out = Vec::<(String, MaterialLiteral)>::new();
    for (index, material) in doc.materials().enumerate() {
        let pbr = material.pbr_metallic_roughness();
        let base_color = pbr.base_color_factor();
        let emissive_factor = material.emissive_factor();
        let derived = MaterialLiteral {
            base_color_factor: base_color,
            roughness_factor: pbr.roughness_factor(),
            metallic_factor: pbr.metallic_factor(),
            occlusion_strength: material
                .occlusion_texture()
                .map(|occ| occ.strength())
                .unwrap_or(1.0),
            emissive_factor,
            alpha_mode: match material.alpha_mode() {
                gltf::material::AlphaMode::Opaque => 0,
                gltf::material::AlphaMode::Mask => 1,
                gltf::material::AlphaMode::Blend => 2,
            },
            alpha_cutoff: material.alpha_cutoff().unwrap_or(0.5),
            double_sided: material.double_sided(),
            normal_scale: material
                .normal_texture()
                .map(|normal| normal.scale())
                .unwrap_or(1.0),
            base_color_texture: pbr
                .base_color_texture()
                .map(|tex| tex.texture().index() as u32)
                .unwrap_or(u32::MAX),
            metallic_roughness_texture: pbr
                .metallic_roughness_texture()
                .map(|tex| tex.texture().index() as u32)
                .unwrap_or(u32::MAX),
            normal_texture: material
                .normal_texture()
                .map(|tex| tex.texture().index() as u32)
                .unwrap_or(u32::MAX),
            occlusion_texture: material
                .occlusion_texture()
                .map(|tex| tex.texture().index() as u32)
                .unwrap_or(u32::MAX),
            emissive_texture: material
                .emissive_texture()
                .map(|tex| tex.texture().index() as u32)
                .unwrap_or(u32::MAX),
        };
        out.push((format!("{res_path}:mat[{index}]"), derived));
    }
    if out.is_empty() {
        out.push((
            format!("{res_path}:mat[0]"),
            MaterialLiteral {
                base_color_factor: [0.85, 0.85, 0.85, 1.0],
                roughness_factor: 0.5,
                metallic_factor: 0.0,
                occlusion_strength: 1.0,
                emissive_factor: [0.0, 0.0, 0.0],
                alpha_mode: 0,
                alpha_cutoff: 0.5,
                double_sided: false,
                normal_scale: 1.0,
                base_color_texture: u32::MAX,
                metallic_roughness_texture: u32::MAX,
                normal_texture: u32::MAX,
                occlusion_texture: u32::MAX,
                emissive_texture: u32::MAX,
            },
        ));
    }
    Ok(out)
}
