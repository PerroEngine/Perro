use crate::{StaticPipelineError, res_dir, static_dir};
use perro_io::walkdir::walk_dir;
use perro_scene::{Parser, RuntimeValue};
use std::{collections::HashMap, fmt::Write as _, fs, path::Path};

pub fn generate_static_materials(project_root: &Path) -> Result<(), StaticPipelineError> {
    let res_dir = res_dir(project_root);
    let static_dir = static_dir(project_root);
    fs::create_dir_all(&static_dir)?;

    let mut materials: Vec<(String, MaterialLiteral)> = Vec::new();
    if res_dir.exists() {
        walk_dir(&res_dir, &mut |path| {
            if path.extension().and_then(|e| e.to_str()) != Some("pmat") {
                return Ok(());
            }
            let rel = path.strip_prefix(&res_dir).unwrap().to_string_lossy().replace('\\', "/");
            let res_path = format!("res://{rel}");
            let src = fs::read_to_string(path)?;
            let parsed = std::panic::catch_unwind(|| Parser::new(&src).parse_value_literal())
                .map_err(|_| {
                    std::io::Error::other(format!("failed to parse material: {res_path}"))
                })?;
            let material = material_from_runtime_value(&parsed).ok_or_else(|| {
                std::io::Error::other(format!(
                    "material `{res_path}` must be an object with at least one valid field"
                ))
            })?;
            materials.push((res_path, material));
            Ok(())
        })?;
    }

    materials.sort_by(|a, b| a.0.cmp(&b.0));

    let mut unique_materials = Vec::<MaterialLiteral>::new();
    let mut unique_by_key = HashMap::<MaterialKey, usize>::new();
    let mut material_refs = Vec::<(String, usize)>::with_capacity(materials.len());
    for (path, material) in materials {
        let key = MaterialKey::from(material);
        let index = if let Some(existing) = unique_by_key.get(&key).copied() {
            existing
        } else {
            let idx = unique_materials.len();
            unique_materials.push(material);
            unique_by_key.insert(key, idx);
            idx
        };
        material_refs.push((path, index));
    }

    let mut out = String::new();
    out.push_str("// Auto-generated by Perro Static Pipeline. Do not edit.\n");
    out.push_str("use perro_render_bridge::Material3D;\n\n");
    for (index, material) in unique_materials.iter().enumerate() {
        let const_name = format!("MATERIAL_{}", index);
        let _ = writeln!(
            out,
            "static {const_name}: Material3D = Material3D {{ base_color: [{:.6}, {:.6}, {:.6}, {:.6}], roughness: {:.6}, metallic: {:.6}, ao: {:.6}, emissive: {:.6} }};",
            material.base_color[0],
            material.base_color[1],
            material.base_color[2],
            material.base_color[3],
            material.roughness,
            material.metallic,
            material.ao,
            material.emissive
        );
    }
    out.push('\n');
    out.push_str("pub fn lookup_material(path: &str) -> Option<&'static Material3D> {\n");
    out.push_str("    match path {\n");
    for (path, index) in &material_refs {
        let _ = writeln!(
            out,
            "        \"{}\" => Some(&MATERIAL_{}),",
            escape_str(path),
            index
        );
    }
    out.push_str("        _ => None,\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    fs::write(static_dir.join("materials.rs"), out)?;
    Ok(())
}

#[derive(Clone, Copy)]
struct MaterialLiteral {
    base_color: [f32; 4],
    roughness: f32,
    metallic: f32,
    ao: f32,
    emissive: f32,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
struct MaterialKey {
    base_color: [u32; 4],
    roughness: u32,
    metallic: u32,
    ao: u32,
    emissive: u32,
}

impl From<MaterialLiteral> for MaterialKey {
    fn from(value: MaterialLiteral) -> Self {
        Self {
            base_color: [
                value.base_color[0].to_bits(),
                value.base_color[1].to_bits(),
                value.base_color[2].to_bits(),
                value.base_color[3].to_bits(),
            ],
            roughness: value.roughness.to_bits(),
            metallic: value.metallic.to_bits(),
            ao: value.ao.to_bits(),
            emissive: value.emissive.to_bits(),
        }
    }
}

fn material_from_runtime_value(value: &RuntimeValue) -> Option<MaterialLiteral> {
    let RuntimeValue::Object(entries) = value else {
        return None;
    };
    let mut out = MaterialLiteral {
        base_color: [0.85, 0.85, 0.85, 1.0],
        roughness: 0.5,
        metallic: 0.0,
        ao: 1.0,
        emissive: 0.0,
    };
    let mut any = false;
    for (name, value) in entries {
        match name.as_str() {
            "roughness" => {
                if let Some(v) = runtime_as_f32(value) {
                    out.roughness = v;
                    any = true;
                }
            }
            "metallic" => {
                if let Some(v) = runtime_as_f32(value) {
                    out.metallic = v;
                    any = true;
                }
            }
            "ao" => {
                if let Some(v) = runtime_as_f32(value) {
                    out.ao = v;
                    any = true;
                }
            }
            "emissive" => {
                if let Some(v) = runtime_as_f32(value) {
                    out.emissive = v;
                    any = true;
                }
            }
            "base_color" | "albedo" | "color" => {
                if let Some(color) = runtime_as_color4(value) {
                    out.base_color = color;
                    any = true;
                }
            }
            _ => {}
        }
    }
    any.then_some(out)
}

fn runtime_as_f32(value: &RuntimeValue) -> Option<f32> {
    match value {
        RuntimeValue::F32(v) => Some(*v),
        RuntimeValue::I32(v) => Some(*v as f32),
        _ => None,
    }
}

fn runtime_as_color4(value: &RuntimeValue) -> Option<[f32; 4]> {
    match value {
        RuntimeValue::Vec4 { x, y, z, w } => Some([*x, *y, *z, *w]),
        RuntimeValue::Vec3 { x, y, z } => Some([*x, *y, *z, 1.0]),
        _ => None,
    }
}

fn escape_str(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}
