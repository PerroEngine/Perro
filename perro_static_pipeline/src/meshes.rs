use crate::{StaticPipelineError, embedded_dir, res_dir, static_dir};
use perro_io::{compress_zlib_best, walkdir::walk_dir};
use std::{
    fmt::Write as _,
    fs,
    io,
    path::{Path, PathBuf},
};

const PMESH_MAGIC: &[u8; 5] = b"PMESH";
const PMESH_VERSION: u32 = 1;

#[derive(Clone, Copy)]
struct PackedVertex {
    position: [f32; 3],
    normal: [f32; 3],
}

#[derive(Clone, Copy)]
struct PackedMaterial {
    base_color: [f32; 4],
    roughness: f32,
    metallic: f32,
    ao: f32,
    emissive: f32,
}

#[derive(Clone)]
struct MeshRef {
    lookup_key: String,
    embedded_rel_path: String,
}

pub fn generate_static_meshes(project_root: &Path) -> Result<(), StaticPipelineError> {
    let res_dir = res_dir(project_root);
    let static_dir = static_dir(project_root);
    let embedded_meshes_dir = embedded_dir(project_root).join("meshes");
    fs::create_dir_all(&static_dir)?;
    fs::create_dir_all(&embedded_meshes_dir)?;

    let mut mesh_refs = Vec::<MeshRef>::new();
    if res_dir.exists() {
        walk_dir(&res_dir, &mut |path| {
            let Some(ext) = path.extension().and_then(|e| e.to_str()) else {
                return Ok(());
            };
            let ext = ext.to_ascii_lowercase();
            let rel = path
                .strip_prefix(&res_dir)
                .unwrap()
                .to_string_lossy()
                .replace('\\', "/");
            let res_path = format!("res://{rel}");
            match ext.as_str() {
                "pmesh" => {
                    let output_path = embedded_meshes_dir.join(&rel);
                    if let Some(parent) = output_path.parent() {
                        fs::create_dir_all(parent)?;
                    }
                    fs::copy(path, &output_path)?;
                    mesh_refs.push(MeshRef {
                        lookup_key: res_path,
                        embedded_rel_path: rel,
                    });
                }
                "glb" | "gltf" => {
                    let entries = build_gltf_mesh_entries(path, &res_path, &rel)?;
                    for (entry, bytes) in entries {
                        let output_path = embedded_meshes_dir.join(&entry.embedded_rel_path);
                        if let Some(parent) = output_path.parent() {
                            fs::create_dir_all(parent)?;
                        }
                        fs::write(&output_path, bytes)?;
                        mesh_refs.push(entry);
                    }
                }
                _ => {}
            }
            Ok(())
        })?;
    }

    mesh_refs.sort_by(|a, b| a.lookup_key.cmp(&b.lookup_key));
    mesh_refs.dedup_by(|a, b| a.lookup_key == b.lookup_key);

    let mut out = String::new();
    out.push_str("// Auto-generated by Perro Static Pipeline. Do not edit.\n");
    out.push_str("#![allow(dead_code)]\n\n");
    for (index, mesh_ref) in mesh_refs.iter().enumerate() {
        let include_path = format!(
            "../../embedded/meshes/{}",
            escape_str(&mesh_ref.embedded_rel_path)
        );
        let _ = writeln!(
            out,
            "static MESH_{index}: &[u8] = include_bytes!(\"{include_path}\");"
        );
    }
    if !mesh_refs.is_empty() {
        out.push('\n');
    }
    out.push_str("pub fn lookup_mesh(path: &str) -> Option<&'static [u8]> {\n");
    out.push_str("    match path {\n");
    for (index, mesh_ref) in mesh_refs.iter().enumerate() {
        let _ = writeln!(
            out,
            "        \"{}\" => Some(MESH_{index}),",
            escape_str(&mesh_ref.lookup_key)
        );
    }
    out.push_str("        _ => None,\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    fs::write(static_dir.join("meshes.rs"), out)?;
    Ok(())
}

fn build_gltf_mesh_entries(
    path: &Path,
    res_path: &str,
    rel: &str,
) -> io::Result<Vec<(MeshRef, Vec<u8>)>> {
    let (doc, buffers, _images) = gltf::import(path)
        .map_err(|err| io::Error::other(format!("failed to import model `{res_path}`: {err}")))?;

    let mut entries = Vec::<(MeshRef, Vec<u8>)>::new();
    let mut rel_base = PathBuf::from(rel);
    rel_base.set_extension("");
    let rel_base = rel_base.to_string_lossy().replace('\\', "/");

    for (mesh_index, mesh) in doc.meshes().enumerate() {
        let Some(primitive) = mesh.primitives().next() else {
            continue;
        };
        let reader = primitive.reader(|buffer| {
            buffers
                .get(buffer.index())
                .map(|data| data.0.as_slice())
        });

        let Some(positions) = reader.read_positions() else {
            continue;
        };
        let mut vertices = Vec::<PackedVertex>::new();
        let normals: Vec<[f32; 3]> = reader
            .read_normals()
            .map(|iter| iter.collect())
            .unwrap_or_default();
        for (index, position) in positions.enumerate() {
            let normal = normals.get(index).copied().unwrap_or([0.0, 1.0, 0.0]);
            vertices.push(PackedVertex { position, normal });
        }
        if vertices.is_empty() {
            continue;
        }

        let indices: Vec<u32> = if let Some(read_indices) = reader.read_indices() {
            read_indices.into_u32().collect()
        } else {
            (0..vertices.len() as u32).collect()
        };

        let material = material_from_gltf(primitive.material());
        let pmesh = encode_pmesh(&vertices, &indices, &[material])?;

        let embedded_rel_path = format!("{rel_base}_mesh{mesh_index}.pmesh");
        let key_bracket = format!("{res_path}:mesh[{mesh_index}]");
        entries.push((
            MeshRef {
                lookup_key: key_bracket,
                embedded_rel_path,
            },
            pmesh,
        ));
    }

    Ok(entries)
}

fn material_from_gltf(material: gltf::Material<'_>) -> PackedMaterial {
    let pbr = material.pbr_metallic_roughness();
    let base_color = pbr.base_color_factor();
    let emissive_factor = material.emissive_factor();
    PackedMaterial {
        base_color,
        roughness: pbr.roughness_factor(),
        metallic: pbr.metallic_factor(),
        ao: material
            .occlusion_texture()
            .map(|occ| occ.strength())
            .unwrap_or(1.0),
        emissive: emissive_factor
            .iter()
            .copied()
            .fold(0.0_f32, f32::max),
    }
}

fn encode_pmesh(
    vertices: &[PackedVertex],
    indices: &[u32],
    materials: &[PackedMaterial],
) -> io::Result<Vec<u8>> {
    let mut raw = Vec::<u8>::new();
    raw.reserve(
        vertices.len() * (6 * std::mem::size_of::<f32>())
            + indices.len() * std::mem::size_of::<u32>()
            + materials.len() * (8 * std::mem::size_of::<f32>()),
    );

    for vertex in vertices {
        write_f32(&mut raw, vertex.position[0]);
        write_f32(&mut raw, vertex.position[1]);
        write_f32(&mut raw, vertex.position[2]);
        write_f32(&mut raw, vertex.normal[0]);
        write_f32(&mut raw, vertex.normal[1]);
        write_f32(&mut raw, vertex.normal[2]);
    }
    for &index in indices {
        raw.extend_from_slice(&index.to_le_bytes());
    }
    for material in materials {
        write_f32(&mut raw, material.base_color[0]);
        write_f32(&mut raw, material.base_color[1]);
        write_f32(&mut raw, material.base_color[2]);
        write_f32(&mut raw, material.base_color[3]);
        write_f32(&mut raw, material.roughness);
        write_f32(&mut raw, material.metallic);
        write_f32(&mut raw, material.ao);
        write_f32(&mut raw, material.emissive);
    }

    let compressed = compress_zlib_best(&raw)?;
    let mut out = Vec::with_capacity(5 + 5 * std::mem::size_of::<u32>() + compressed.len());
    out.extend_from_slice(PMESH_MAGIC);
    out.extend_from_slice(&PMESH_VERSION.to_le_bytes());
    out.extend_from_slice(&(vertices.len() as u32).to_le_bytes());
    out.extend_from_slice(&(indices.len() as u32).to_le_bytes());
    out.extend_from_slice(&(materials.len() as u32).to_le_bytes());
    out.extend_from_slice(&(raw.len() as u32).to_le_bytes());
    out.extend_from_slice(&compressed);
    Ok(out)
}

fn write_f32(out: &mut Vec<u8>, value: f32) {
    out.extend_from_slice(&value.to_le_bytes());
}

fn escape_str(input: &str) -> String {
    let mut out = String::with_capacity(input.len());
    for ch in input.chars() {
        match ch {
            '\\' => out.push_str("\\\\"),
            '"' => out.push_str("\\\""),
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            _ => out.push(ch),
        }
    }
    out
}
