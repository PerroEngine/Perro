use crate::{StaticPipelineError, embedded_dir, res_dir, static_dir};
use perro_io::{compress_zlib_best, walkdir::walk_dir};
use std::{
    fmt::Write as _,
    fs,
    path::{Path, PathBuf},
};

const IMAGE_EXTENSIONS: &[&str] = &[
    "png", "jpg", "jpeg", "bmp", "gif", "ico", "tga", "webp", "rgba",
];

pub fn generate_static_textures(project_root: &Path) -> Result<(), StaticPipelineError> {
    let res_dir = res_dir(project_root);
    let static_dir = static_dir(project_root);
    let embedded_textures_dir = embedded_dir(project_root).join("textures");
    fs::create_dir_all(&static_dir)?;
    fs::create_dir_all(&embedded_textures_dir)?;

    let mut textures = Vec::<(String, String)>::new();
    if res_dir.exists() {
        walk_dir(&res_dir, &mut |path| {
            let Some(ext) = path.extension().and_then(|e| e.to_str()) else {
                return Ok(());
            };
            if !IMAGE_EXTENSIONS.contains(&ext) {
                return Ok(());
            }

            let rel = path.strip_prefix(&res_dir).unwrap().to_string_lossy().replace('\\', "/");
            let res_path = format!("res://{rel}");
            let file_bytes = fs::read(path)?;
            let image = image::load_from_memory(&file_bytes).map_err(|err| {
                std::io::Error::other(format!("failed to decode image `{res_path}`: {err}"))
            })?;
            let rgba = image.to_rgba8();
            let (width, height) = rgba.dimensions();
            let raw = rgba.into_raw();
            let compressed = compress_zlib_best(&raw)?;

            let mut ptex = Vec::with_capacity(20 + compressed.len());
            ptex.extend_from_slice(b"PTEX");
            ptex.extend_from_slice(&1u32.to_le_bytes());
            ptex.extend_from_slice(&width.to_le_bytes());
            ptex.extend_from_slice(&height.to_le_bytes());
            ptex.extend_from_slice(&(raw.len() as u32).to_le_bytes());
            ptex.extend_from_slice(&compressed);

            let mut rel_ptex = PathBuf::from(&rel);
            rel_ptex.set_extension("ptex");
            let rel_ptex = rel_ptex.to_string_lossy().replace('\\', "/");
            let output_path = embedded_textures_dir.join(&rel_ptex);
            if let Some(parent) = output_path.parent() {
                fs::create_dir_all(parent)?;
            }
            fs::write(&output_path, &ptex)?;

            textures.push((res_path, rel_ptex));
            Ok(())
        })?;
    }

    textures.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// Auto-generated by Perro Static Pipeline. Do not edit.\n\n");
    for (index, (_res_path, rel_ptex)) in textures.iter().enumerate() {
        let include_path = format!("../../embedded/textures/{}", escape_str(rel_ptex));
        let _ = writeln!(
            out,
            "static TEXTURE_{index}: &[u8] = include_bytes!(\"{include_path}\");"
        );
    }
    if !textures.is_empty() {
        out.push('\n');
    }
    out.push_str("pub fn lookup_texture(path: &str) -> Option<&'static [u8]> {\n");
    out.push_str("    match path {\n");
    for (index, (res_path, _)) in textures.iter().enumerate() {
        let _ = writeln!(
            out,
            "        \"{}\" => Some(TEXTURE_{index}),",
            escape_str(res_path)
        );
    }
    out.push_str("        _ => None,\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    fs::write(static_dir.join("textures.rs"), out)?;
    Ok(())
}

fn escape_str(input: &str) -> String {
    let mut out = String::with_capacity(input.len());
    for ch in input.chars() {
        match ch {
            '\\' => out.push_str("\\\\"),
            '"' => out.push_str("\\\""),
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            _ => out.push(ch),
        }
    }
    out
}
