#![allow(improper_ctypes_definitions)]
#![allow(unused)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]

use std::{
    any::Any,
    borrow::Cow,
    cell::RefCell,
    collections::HashMap,
    ops::{Deref, DerefMut},
    rc::Rc,
    str::FromStr,
};

use num_bigint::BigInt;
use phf::{phf_map, Map};
use rust_decimal::Decimal;
use rust_decimal::prelude::{FromPrimitive, ToPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use smallvec::{smallvec, SmallVec};
use perro_core::{TextureID, NodeID, MaterialID, MeshID, LightID, UIElementID, SignalID};

use perro_core::nodes::ui::ui_registry::UIElementType;
use perro_core::nodes::ui::ui_elements::{ui_button, ui_text};

use perro_core::prelude::*;

//=======================================;
// Auto Generated by Perro Transpiler [Any further edits to this file will be overwritten on next transile];
//=======================================;

const __PERRO_SOURCE_FILE: &str = "test_node2d_api.pup";

// ========================================================================
// PuptestsNodeTestsTestNode2dApiPup - Main Script Structure
// ========================================================================

static MEMBER_TO_ATTRIBUTES_MAP: Map<&'static str, &'static [&'static str]> = phf_map! {
};

static ATTRIBUTE_TO_MEMBERS_MAP: Map<&'static str, &'static [&'static str]> = phf_map! {
};

pub struct PuptestsNodeTestsTestNode2dApiPupScript {
    id: NodeID,
    __t_acc: f32,
}

// ========================================================================
// PuptestsNodeTestsTestNode2dApiPup - Creator Function (FFI Entry Point)
// ========================================================================

#[unsafe(no_mangle)]
pub extern "C" fn puptests_node_tests_test_node2d_api_pup_create_script() -> *mut dyn ScriptObject {
    let id = NodeID::nil(); // Will be set when attached to node
    let acc = 0.0f32;

    Box::into_raw(Box::new(PuptestsNodeTestsTestNode2dApiPupScript {
        id,
        __t_acc: acc,
    })) as *mut dyn ScriptObject
}

// ========================================================================
// PuptestsNodeTestsTestNode2dApiPup - Script Init & Update Implementation
// ========================================================================

impl Script for PuptestsNodeTestsTestNode2dApiPupScript {
    fn init(&mut self, api: &mut ScriptApi<'_>) {
        self.__t_test_transform_read_write(api);
        self.__t_test_transform_assign_to_other(api);
        self.__t_test_node_methods(api);
        self.__t_test_call_deferred(api);
        self.__t_test_for_loops(api);
    }

}

// ========================================================================
// PuptestsNodeTestsTestNode2dApiPup - Script-Defined Methods
// ========================================================================

impl PuptestsNodeTestsTestNode2dApiPupScript {
    fn __t_test_transform_read_write(&mut self, api: &mut ScriptApi<'_>) {
        let mut __t_t: Transform2D = (api.read_node(self.id, |self_node: &Node2D| self_node.transform));
        let mut __t_pos: Vector2 = (api.read_node(self.id, |self_node: &Node2D| self_node.transform.position));
        let mut __t_x: f32 = (api.read_node(self.id, |self_node: &Node2D| self_node.transform.position.x));
        let mut __t_y: f32 = (api.read_node(self.id, |self_node: &Node2D| self_node.transform.position.y));
        api.mutate_node(self.id, |self_node: &mut Node2D| {
            self_node.transform.position = Vector2::new(1.0f32, 2.0f32);
            self_node.transform.position.x = 10.0f32;
            self_node.transform.position.y = 20.0f32;
        });
        let mut __t_gt: Transform2D = api.get_global_transform(self.id).unwrap_or_default();
        let mut __t_pv: Vector2 = (api.read_node(self.id, |self_node: &Node2D| self_node.pivot));
        api.mutate_node(self.id, |self_node: &mut Node2D| { self_node.pivot = Vector2::new(0.5f32, 0.5f32); });
        let mut __t_vis: bool = (api.read_node(self.id, |self_node: &Node2D| self_node.visible));
        api.mutate_node(self.id, |self_node: &mut Node2D| { self_node.visible = true; });
        let mut __t_zi: i32 = (api.read_node(self.id, |self_node: &Node2D| self_node.z_index));
        api.mutate_node(self.id, |self_node: &mut Node2D| { self_node.z_index = 1i32; });
        let mut __t_n: Cow<'static, str> = api.read_scene_node(self.id, |n| Cow::Owned(n.get_name().to_string()));
        api.mutate_scene_node(self.id, |n| { n.set_name(Cow::Borrowed("TestNode2D")); });
    }

    fn __t_test_transform_assign_to_other(&mut self, api: &mut ScriptApi<'_>) {
        let mut __t_other_pos: Vector2 = Vector2::new(5.0f32, 5.0f32);
        api.mutate_node(self.id, |self_node: &mut Node2D| { self_node.transform.position = __t_other_pos; });
        let mut __t_copy: Vector2 = (api.read_node(self.id, |self_node: &Node2D| self_node.transform.position));
        api.mutate_node(self.id, |self_node: &mut Node2D| { self_node.transform.position = __t_copy; });
        let mut __t_t2: Transform2D = api.get_global_transform(self.id).unwrap_or_default();
        let mut __t_pos_from_t: Vector2 = __t_t2.position;
        api.mutate_node(self.id, |self_node: &mut Node2D| { self_node.transform.position = __t_pos_from_t; });
    }

    fn __t_test_node_methods(&mut self, api: &mut ScriptApi<'_>) {
        let mut parent_id: NodeID = api.get_parent(self.id);
        let mut child_id: Option<NodeID> = api.get_child_by_name(self.id, "Child");
        let mut __t_ty: NodeType = api.get_type(self.id);
        let mut __t_pty: NodeType = api.get_parent_type(self.id);
        api.set_script_var_id(self.id, 1032136658935082110u64, json!(json!(json!(42f32))));
        let mut __t_v: Value = api.get_script_var_id(self.id, 1032136658935082110u64);
        api.call_function_id(self.id, 14019570758099282180u64, &[json!(json!(1.0f32))]);
        let mut c_id: Option<NodeID> = api.get_child_by_name(self.id, "Other");
        if c_id.is_some() {
            let mut __t_cv = api.get_script_var_id(c_id.expect("Child node not found"), 1903775884355078583u64);
            let temp_api_var_0: f32 = api.Time.get_delta(); api.call_function_id(c_id.expect("Child node not found"), 17956486561529147460u64, &[json!(temp_api_var_0)]);
        }
    }

    fn __t_test_call_deferred(&mut self, api: &mut ScriptApi<'_>) {
        api.call_function_id_deferred(self.id, 14019570758099282180u64, &[json!(json!(2.0f32))]);
        let mut other_id: Option<NodeID> = api.get_child_by_name(self.id, "Other");
        if other_id.is_some() {
            let temp_api_var_0: f32 = api.Time.get_delta(); api.call_function_id_deferred(other_id.expect("Child node not found"), 17956486561529147460u64, &[json!(temp_api_var_0)]);
        }
    }

    fn __t_test_for_loops(&mut self, api: &mut ScriptApi<'_>) {
        for __t_i in (0i32..10i32) {
            let __temp_read_0: Transform2D = (api.read_node(self.id, |self_node: &Node2D| self_node.transform));
            api.mutate_node(self.id, |self_node: &mut Node2D| { self_node.transform.position.x = (__temp_read_0.position.x + 0.1f32); });
        }
        for __t_j in (0i32..5i32) {
            self.__t_acc = (self.__t_acc + api.Time.get_delta());
            let mut __t_pos: Vector2 = (api.read_node(self.id, |self_node: &Node2D| self_node.transform.position));
            api.mutate_node(self.id, |self_node: &mut Node2D| { self_node.transform.position = Vector2::new(((__t_pos.x as f32) + 0.01f32), __t_pos.y); });
        }
    }

    fn __t_some_script_fn(&mut self, mut __t_x: f32, api: &mut ScriptApi<'_>) {
        self.__t_acc = (self.__t_acc + (__t_x as f32));
    }

}


impl ScriptObject for PuptestsNodeTestsTestNode2dApiPupScript {
    fn set_id(&mut self, id: NodeID) {
        self.id = id;
    }

    fn get_id(&self) -> NodeID {
        self.id
    }

    fn get_var(&self, var_id: u64) -> Option<Value> {
        VAR_GET_TABLE.get(&var_id).and_then(|f| f(self))
    }

    fn set_var(&mut self, var_id: u64, val: Value) -> Option<()> {
        VAR_SET_TABLE.get(&var_id).and_then(|f| f(self, val))
    }

    fn apply_exposed(&mut self, hashmap: &HashMap<u64, Value>, api: &mut ScriptApi<'_>) {
        for (var_id, val) in hashmap.iter() {
            if let Some(f) = VAR_APPLY_TABLE.get(var_id) {
                f(self, val, api);
            }
        }
    }

    fn call_function(
        &mut self,
        id: u64,
        api: &mut ScriptApi<'_>,
        params: &[Value],
    ) -> Value {
        DISPATCH_TABLE.get(&id).map_or(Value::Null, |f| f(self, params, api))
    }

    // Attributes

    fn attributes_of(&self, member: &str) -> Vec<String> {
        MEMBER_TO_ATTRIBUTES_MAP
            .get(member)
            .map(|attrs| attrs.iter().map(|s| s.to_string()).collect())
            .unwrap_or_default()
    }

    fn members_with(&self, attribute: &str) -> Vec<String> {
        ATTRIBUTE_TO_MEMBERS_MAP
            .get(attribute)
            .map(|members| members.iter().map(|s| s.to_string()).collect())
            .unwrap_or_default()
    }

    fn has_attribute(&self, member: &str, attribute: &str) -> bool {
        MEMBER_TO_ATTRIBUTES_MAP
            .get(member)
            .map(|attrs| attrs.iter().any(|a| *a == attribute))
            .unwrap_or(false)
    }
    
    fn script_flags(&self) -> ScriptFlags {
        ScriptFlags::new(1)
    }
}

// =========================== Static PHF Dispatch Tables ===========================

static VAR_GET_TABLE: phf::Map<u64, fn(&PuptestsNodeTestsTestNode2dApiPupScript) -> Option<Value>> =
    phf::phf_map! {
        8594669766308487599u64 => |script: &PuptestsNodeTestsTestNode2dApiPupScript| -> Option<Value> {
                        Some(json!(script.__t_acc))
                    },

    };

static VAR_SET_TABLE: phf::Map<u64, fn(&mut PuptestsNodeTestsTestNode2dApiPupScript, Value) -> Option<()>> =
    phf::phf_map! {
        8594669766308487599u64 => |script: &mut PuptestsNodeTestsTestNode2dApiPupScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_f64() {
                                script.__t_acc = v as f32;
                                return Some(());
                            }
                            None
                        },

    };

static VAR_APPLY_TABLE: phf::Map<u64, fn(&mut PuptestsNodeTestsTestNode2dApiPupScript, &Value, &mut ScriptApi<'_>)> =
    phf::phf_map! {

    };

static DISPATCH_TABLE: phf::Map<
    u64,
    fn(&mut PuptestsNodeTestsTestNode2dApiPupScript, &[Value], &mut ScriptApi<'_>) -> Value,
> = phf::phf_map! {
        432816268499948822u64 => | script: &mut PuptestsNodeTestsTestNode2dApiPupScript, params: &[Value], api: &mut ScriptApi<'_>| -> Value {
            script.__t_test_transform_read_write(api);
            Value::Null
        },
        10634414633195722237u64 => | script: &mut PuptestsNodeTestsTestNode2dApiPupScript, params: &[Value], api: &mut ScriptApi<'_>| -> Value {
            script.__t_test_transform_assign_to_other(api);
            Value::Null
        },
        4508521169317302366u64 => | script: &mut PuptestsNodeTestsTestNode2dApiPupScript, params: &[Value], api: &mut ScriptApi<'_>| -> Value {
            script.__t_test_node_methods(api);
            Value::Null
        },
        16792569369795758087u64 => | script: &mut PuptestsNodeTestsTestNode2dApiPupScript, params: &[Value], api: &mut ScriptApi<'_>| -> Value {
            script.__t_test_call_deferred(api);
            Value::Null
        },
        4985906182962114350u64 => | script: &mut PuptestsNodeTestsTestNode2dApiPupScript, params: &[Value], api: &mut ScriptApi<'_>| -> Value {
            script.__t_test_for_loops(api);
            Value::Null
        },
        14019570758099282180u64 => | script: &mut PuptestsNodeTestsTestNode2dApiPupScript, params: &[Value], api: &mut ScriptApi<'_>| -> Value {
let __t_x = params.get(0)
                            .and_then(|v| v.as_f64().or_else(|| v.as_i64().map(|i| i as f64)))
                            .unwrap_or_default() as f32;
            script.__t_some_script_fn(__t_x, api);
            Value::Null
        },

    };
