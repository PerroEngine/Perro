#![allow(improper_ctypes_definitions)]
#![allow(unused)]

use std::{
    any::Any,
    cell::RefCell,
    collections::HashMap,
    ops::{Deref, DerefMut},
    rc::Rc,
    str::FromStr,
};

use num_bigint::BigInt;
use phf::{phf_map, Map};
use rust_decimal::Decimal;
use rust_decimal::prelude::{FromPrimitive, ToPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use smallvec::{smallvec, SmallVec};
use uuid::Uuid;

use perro_core::prelude::*;

//=======================================;
// Auto Generated by Perro Transpiler [Any further edits to this file will be overwritten on next transile];
//=======================================;

// ========================================================================
// TypesTs - Main Script Structure
// ========================================================================

static MEMBER_TO_ATTRIBUTES_MAP: Map<&'static str, &'static [&'static str]> = phf_map! {
};

static ATTRIBUTE_TO_MEMBERS_MAP: Map<&'static str, &'static [&'static str]> = phf_map! {
};

pub struct TypesTsScript {
    base: Node,
    untyped_num_default: f64,
    typed_int_default: f64,
    typed_int_8: f64,
    typed_int_64: f64,
    typed_uint_16: f64,
    typed_float_default: f64,
    typed_float_64: f64,
    typed_big_int: BigInt,
    typed_decimal: f64,
    typed_string: String,
    local_int: f64,
    local_uint_8: f64,
    local_float: f64,
    local_string: String,
    local_big_int: BigInt,
    local_decimal: f64,
    testVector: TestVector,
    gameEntity: GameEntity,
    testPlayer: TestPlayer,
    superTestPlayer: SuperTestPlayer,
    my_base_entity: GameEntity,
    my_player: TestPlayer,
    other_player: TestPlayer,
    my_derived_player: SuperTestPlayer,
    my_derived_player_var: SuperTestPlayer,
    dynamic_array_inferred: Vec<Value>,
    dynamic_map_inferred: HashMap<String, Value>,
    dynamic_array_annotated: Vec<Value>,
    dynamic_map_annotated: HashMap<String, Value>,
    static_array_int: Vec<f64>,
    static_array_uint_16: Vec<f64>,
    static_array_string: Vec<String>,
    static_array_float_64: Vec<f64>,
    static_array_big_int: Vec<BigInt>,
    static_array_decimal: Vec<f64>,
    static_map_string_int_64: HashMap<String, Value>,
    static_map_int_string: HashMap<String, Value>,
    static_map_uint_8_float: HashMap<String, Value>,
    static_map_string_big: HashMap<String, Value>,
    static_map_string_decimal: HashMap<String, Value>,
    static_array_entities: Vec<Value>,
    static_array_players: Vec<Value>,
    static_map_players: HashMap<String, Value>,
    static_map_super_players: HashMap<String, Value>,
}

// ========================================================================
// TypesTs - Creator Function (FFI Entry Point)
// ========================================================================

#[unsafe(no_mangle)]
pub extern "C" fn types_ts_create_script() -> *mut dyn ScriptObject {
    let base = Node::new("TypesTs", None);
    let untyped_num_default = 10f64;
    let typed_int_default = 20f64;
    let typed_int_8 = 0.0f64;
    let typed_int_64 = 1_000_000_000_000f64;
    let typed_uint_16 = 60000f64;
    let typed_float_default = 30.5f64;
    let typed_float_64 = 123.456_789f64;
    let typed_big_int = BigInt::from_str(String::from("12345678901234567890").as_ref()).unwrap_or_default();
    let typed_decimal = 987.6543210987654321f64;
    let typed_string = String::from("HelloPerro");
    let local_int = 5f64;
    let local_uint_8 = 250f64;
    let local_float = 2.5f64;
    let local_string = String::from("LocalString");
    let local_big_int = BigInt::from_str(String::from("1000000000000000000").as_ref()).unwrap_or_default();
    let local_decimal = 12.34567890123456789f64;
    let testVector = Default::default();
    let gameEntity = Default::default();
    let testPlayer = Default::default();
    let superTestPlayer = Default::default();
    let my_base_entity = GameEntity { entity_id: 100f64, ..Default::default() };
    let my_player = TestPlayer { base: GameEntity { entity_id: 1f64, ..Default::default() }, pos: TestVector { x: 0.0f64, y: 0.0f64, ..Default::default() }, health: 100.0f64, mana: 50f64, ..Default::default() };
    let other_player = TestPlayer { base: GameEntity { entity_id: 2f64, ..Default::default() }, pos: TestVector { x: 5.0f64, y: 10.0f64, ..Default::default() }, health: 80.0f64, mana: 30f64, ..Default::default() };
    let my_derived_player = SuperTestPlayer { base: TestPlayer { base: GameEntity { entity_id: 3f64, ..Default::default() }, pos: TestVector { x: 10.0f64, y: 10.0f64, ..Default::default() }, health: 200.0f64, mana: 100f64, ..Default::default() }, energy_core: 99.9f64, ..Default::default() };
    let my_derived_player_var = SuperTestPlayer { base: TestPlayer { base: GameEntity { entity_id: 4f64, ..Default::default() }, pos: TestVector { x: 20.0f64, y: 20.0f64, ..Default::default() }, health: 180.0f64, mana: 80f64, ..Default::default() }, energy_core: 80.0f64, ..Default::default() };
    let dynamic_array_inferred = vec![json!(json!(1f32)), json!(json!(String::from("two"))), json!(json!(3.0f32)), json!(untyped_num_default), json!(typed_big_int.clone()), json!(typed_decimal)];
    let dynamic_map_inferred = HashMap::<String, Value>::from([(String::from("alpha"), json!(json!(1f32))), (String::from("beta"), json!(typed_string.clone())), (String::from("gamma"), json!(typed_big_int.clone())), (String::from("delta"), json!(typed_decimal))]);
    let dynamic_array_annotated = vec![json!(typed_int_default), json!(typed_float_64), json!(my_derived_player_var.clone()), json!(typed_big_int.clone())];
    let dynamic_map_annotated = HashMap::<String, Value>::from([(String::from("char"), json!(json!(String::from("A")))), (String::from("num"), json!(typed_int_8)), (String::from("big_val"), json!(local_big_int.clone()))]);
    let static_array_int = vec![10f64, 20f64, 30f64];
    let static_array_uint_16 = vec![1000f64, 2000f64];
    let static_array_string = vec![String::from("one"), String::from("two"), String::from("three")];
    let static_array_float_64 = vec![1.11f64, 2.22f64, 3.33f64];
    let static_array_big_int = vec![BigInt::from(100f32 as i32), BigInt::from(200f32 as i32), typed_big_int.clone()];
    let static_array_decimal = vec![5.5f64, 6.6f64, typed_decimal];
    let static_map_string_int_64 = HashMap::<String, Value>::from([(String::from("level"), json!(json!(10_000_000_000f32))), (String::from("score"), json!(json!(1_000_000_000f32)))]);
    let static_map_int_string = HashMap::<String, Value>::from([(1f32.to_string(), json!(json!(String::from("gold")))), (2f32.to_string(), json!(json!(String::from("silver"))))]);
    let static_map_uint_8_float = HashMap::<String, Value>::from([(50f32.to_string(), json!(json!(0.5f32))), (100f32.to_string(), json!(json!(1.5f32)))]);
    let static_map_string_big = HashMap::<String, Value>::from([(String::from("large_num"), json!(BigInt::from_str(String::from("9999999999999999999").as_ref()).unwrap_or_default())), (String::from("another_large"), json!(BigInt::from(1000f32 as i32)))]);
    let static_map_string_decimal = HashMap::<String, Value>::from([(String::from("price"), json!(json!(19.99f32))), (String::from("tax"), json!(json!(1.50f32)))]);
    let static_array_entities = vec![json!(my_base_entity.clone()), json!(my_player.clone()), json!(my_derived_player.clone())];
    let static_array_players = vec![json!(my_player.clone()), json!(other_player.clone())];
    let static_map_players = HashMap::<String, Value>::from([(String::from("main"), json!(my_player.clone())), (String::from("other"), json!(other_player.clone()))]);
    let static_map_super_players = HashMap::<String, Value>::from([(String::from("super"), json!(my_derived_player.clone())), (String::from("local_super"), json!(my_derived_player_var.clone()))]);

    Box::into_raw(Box::new(TypesTsScript {
        base,
        untyped_num_default,
        typed_int_default,
        typed_int_8,
        typed_int_64,
        typed_uint_16,
        typed_float_default,
        typed_float_64,
        typed_big_int,
        typed_decimal,
        typed_string,
        local_int,
        local_uint_8,
        local_float,
        local_string,
        local_big_int,
        local_decimal,
        testVector,
        gameEntity,
        testPlayer,
        superTestPlayer,
        my_base_entity,
        my_player,
        other_player,
        my_derived_player,
        my_derived_player_var,
        dynamic_array_inferred,
        dynamic_map_inferred,
        dynamic_array_annotated,
        dynamic_map_annotated,
        static_array_int,
        static_array_uint_16,
        static_array_string,
        static_array_float_64,
        static_array_big_int,
        static_array_decimal,
        static_map_string_int_64,
        static_map_int_string,
        static_map_uint_8_float,
        static_map_string_big,
        static_map_string_decimal,
        static_array_entities,
        static_array_players,
        static_map_players,
        static_map_super_players,
    })) as *mut dyn ScriptObject
}

// ========================================================================
// Supporting Struct Definitions
// ========================================================================

#[derive(Default, Debug, Clone, Serialize, Deserialize)]
pub struct TestVector {
    pub x: f64,
    pub y: f64,
}

impl std::fmt::Display for TestVector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{ ")?;
        write!(f, "x: {:?}, ", self.x)?;
        write!(f, "y: {:?} ", self.y)?;
        write!(f, "}}")
    }
}



#[derive(Default, Debug, Clone, Serialize, Deserialize)]
pub struct GameEntity {
    pub entity_id: f64,
    pub entity_name: String,
    pub entity_type: String,
}

impl std::fmt::Display for GameEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{ ")?;
        write!(f, "entity_id: {:?}, ", self.entity_id)?;
        write!(f, "entity_name: {:?}, ", self.entity_name)?;
        write!(f, "entity_type: {:?} ", self.entity_type)?;
        write!(f, "}}")
    }
}



#[derive(Default, Debug, Clone, Serialize, Deserialize)]
pub struct TestPlayer {
    pub base: GameEntity,
    pub pos: TestVector,
    pub health: f64,
    pub mana: f64,
}

impl std::fmt::Display for TestPlayer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{ ")?;
        // Flatten base Display
        let base_str = format!("{}", self.base);
        let base_inner = base_str.trim_matches(|c| c == '{' || c == '}').trim();
        if !base_inner.is_empty() {
            write!(f, "{}", base_inner)?;
            write!(f, ", ")?;
        }
        write!(f, "pos: {:?}, ", self.pos)?;
        write!(f, "health: {:?}, ", self.health)?;
        write!(f, "mana: {:?} ", self.mana)?;
        write!(f, "}}")
    }
}

impl std::ops::Deref for TestPlayer {
    type Target = GameEntity;
    fn deref(&self) -> &Self::Target { &self.base }
}

impl std::ops::DerefMut for TestPlayer {
    fn deref_mut(&mut self) -> &mut Self::Target { &mut self.base }
}



#[derive(Default, Debug, Clone, Serialize, Deserialize)]
pub struct SuperTestPlayer {
    pub base: TestPlayer,
    pub special_ability: String,
    pub energy_core: f64,
}

impl std::fmt::Display for SuperTestPlayer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{ ")?;
        // Flatten base Display
        let base_str = format!("{}", self.base);
        let base_inner = base_str.trim_matches(|c| c == '{' || c == '}').trim();
        if !base_inner.is_empty() {
            write!(f, "{}", base_inner)?;
            write!(f, ", ")?;
        }
        write!(f, "special_ability: {:?}, ", self.special_ability)?;
        write!(f, "energy_core: {:?} ", self.energy_core)?;
        write!(f, "}}")
    }
}

impl std::ops::Deref for SuperTestPlayer {
    type Target = TestPlayer;
    fn deref(&self) -> &Self::Target { &self.base }
}

impl std::ops::DerefMut for SuperTestPlayer {
    fn deref_mut(&mut self) -> &mut Self::Target { &mut self.base }
}



// ========================================================================
// TypesTs - Script Init & Update Implementation
// ========================================================================

impl Script for TypesTsScript {
    fn init(&mut self, api: &mut ScriptApi<'_>) {
        api.print(&String::from("--- START TS MEGA TEST SUITE ---"));
        self.test_primitive_operations(api, false);
        self.test_explicit_casting(api, false);
        self.test_assignments(api, false);
        self.test_struct_inheritance_and_casting(api, false);
        self.test_static_containers_ops(api, false);
        self.test_dynamic_containers_ops(api, false);
        api.print(&String::from("--- ALL TS TESTS COMPLETE ---"));
    }

    fn update(&mut self, api: &mut ScriptApi<'_>) {
        self.test_primitive_operations(api, false);
        self.test_explicit_casting(api, false);
        self.test_assignments(api, false);
        self.test_struct_inheritance_and_casting(api, false);
        self.test_dynamic_containers_ops(api, false);
        self.test_static_containers_ops(api, false);
    }

}

// ========================================================================
// TypesTs - Script-Defined Methods
// ========================================================================

impl TypesTsScript {
    fn test_primitive_operations(&mut self, api: &mut ScriptApi<'_>, external_call: bool) {
        api.print(&String::from("--- Test Primitive Operations ---"));
        let mut res_int: f64 = (self.typed_int_default + (10f64 as f64));
        let mut res_big: BigInt = (self.typed_big_int.clone() + BigInt::from(1000f32 as i32));
        let mut res_decimal: f64 = (self.typed_decimal + (1.000001f64 as f64));
        api.print(&format!("{} {} {} {}", String::from("Var + Lit:"), res_int, res_big, res_decimal));
        let mut res_big_var: BigInt = (self.typed_big_int.clone() + self.local_big_int.clone());
        let mut res_decimal_var: f64 = (self.typed_decimal + self.local_decimal);
        api.print(&format!("{} {} {}", String::from("Var + Var (Big/Dec):"), res_big_var, res_decimal_var));
        let mut prom_float_big: f64 = ((self.typed_int_64 as f64) + self.typed_big_int.to_f64().unwrap_or_default());
        let mut prom_float_decimal: f64 = (self.typed_float_64 + self.typed_decimal);
        let mut prom_big_int: BigInt = (BigInt::from(self.typed_int_64 as i64) + self.typed_big_int.clone());
        api.print(&format!("{} {} {} {}", String::from("Promotion (Big/Dec):"), prom_float_big, prom_float_decimal, prom_big_int));
    }

    fn test_explicit_casting(&mut self, api: &mut ScriptApi<'_>, external_call: bool) {
        api.print(&String::from("--- Test Explicit Casting ---"));
        let mut int64_to_big: BigInt = BigInt::from(self.typed_int_64 as i64);
        let mut big_to_int: f64 = self.typed_big_int.to_f64().unwrap_or_default();
        let mut float_to_decimal: f64 = self.typed_float_default;
        let mut decimal_to_float_64: f64 = self.typed_decimal;
        let mut string_to_uint16: f64 = String::from("65530").parse::<f64>().unwrap_or_default();
        let mut big_to_string: String = self.typed_big_int.to_string();
        api.print(&format!("{} {} {} {} {} {} {}", String::from("Numeric Casts:"), int64_to_big, big_to_int, float_to_decimal, decimal_to_float_64, string_to_uint16, big_to_string));
        let mut dyn_val_big: BigInt = self.dynamic_array_inferred.get(4u32 as usize).cloned().unwrap_or_default().as_str().map(|s| s.parse::<BigInt>().unwrap_or_default()).unwrap_or_else(|| BigInt::from(self.dynamic_array_inferred.get(4u32 as usize).cloned().unwrap_or_default().as_i64().unwrap_or_default()));
        let mut dyn_val_decimal: f64 = self.dynamic_array_inferred.get(5u32 as usize).cloned().unwrap_or_default().as_f64().unwrap_or_default();
        api.print(&format!("{} {} {}", String::from("Dyn->Big/Dec Casts:"), dyn_val_big, dyn_val_decimal));
        let mut casted_and_op_big: BigInt = (self.dynamic_array_inferred.get(0u32 as usize).cloned().unwrap_or_default().as_str().map(|s| s.parse::<BigInt>().unwrap_or_default()).unwrap_or_else(|| BigInt::from(self.dynamic_array_inferred.get(0u32 as usize).cloned().unwrap_or_default().as_i64().unwrap_or_default())) + self.typed_big_int.clone());
        api.print(&format!("{} {}", String::from("Casted & Op (Big):"), casted_and_op_big));
    }

    fn test_assignments(&mut self, api: &mut ScriptApi<'_>, external_call: bool) {
        api.print(&String::from("--- Test Assignments (Simple & Compound) ---"));
        let mut assign_big_lit: BigInt = BigInt::from(999f32 as i32);
        let mut assign_decimal_var: f64 = self.typed_decimal;
        api.print(&format!("{} {} {}", String::from("Simple Assign (Big/Dec):"), assign_big_lit, assign_decimal_var));
        let mut comp_big: BigInt = BigInt::from(100f32 as i32);
        comp_big = (comp_big.clone() + BigInt::from(50f32 as i32));
        api.print(&format!("{} {}", String::from("Comp Assign big +="), comp_big));
        let mut comp_decimal: f64 = 20.0f64;
        comp_decimal = (comp_decimal - (5.5f64 as f64));
        api.print(&format!("{} {}", String::from("Comp Assign decimal -="), comp_decimal));
        let mut assign_prom_decimal: f64 = self.typed_int_default;
        assign_prom_decimal = (assign_prom_decimal + self.typed_float_default);
        api.print(&format!("{} {}", String::from("Assign Promo decimal:"), assign_prom_decimal));
        self.my_player.pos.x = self.typed_big_int.to_f64().unwrap_or_default();
        self.my_player.health = self.typed_decimal;
        api.print(&format!("{} {} {}", String::from("Member Assign (Big/Dec to float):"), self.my_player.pos.x, self.my_player.health));
    }

    fn test_struct_inheritance_and_casting(&mut self, api: &mut ScriptApi<'_>, external_call: bool) {
        api.print(&String::from("--- Test Struct Inheritance & Casting ---"));
        api.print(&format!("{} {}", String::from("Player name (via SuperTestPlayer):"), self.my_derived_player.entity_name));
        api.print(&format!("{} {}", String::from("Entity ID (via SuperTestPlayer):"), self.my_derived_player.entity_id));
        api.print(&format!("{} {}", String::from("Player Health (via SuperTestPlayer):"), self.my_derived_player.health));
        api.print(&format!("{} {}", String::from("SuperTestPlayer ability:"), self.my_derived_player.special_ability));
        api.print(&format!("{} {}", String::from("SuperTestPlayer energy_core:"), self.my_derived_player.energy_core));
        self.my_derived_player.health = (self.my_derived_player.health - (10.0f64 as f64));
        self.my_derived_player.pos.x = (self.my_derived_player.pos.x + (1.0f64 as f64));
        self.my_derived_player.entity_type = String::from("ElitePlayer");
        api.print(&format!("{} {}", String::from("Modified SuperTestPlayer health:"), self.my_derived_player.health));
        api.print(&format!("{} {}", String::from("Modified SuperTestPlayer pos.x:"), self.my_derived_player.pos.x));
        api.print(&format!("{} {}", String::from("Modified SuperTestPlayer entity_type:"), self.my_derived_player.entity_type));
        let mut player_as_entity: GameEntity = serde_json::from_value::<GameEntity>(serde_json::to_value(&self.my_player.clone()).unwrap_or_default()).unwrap_or_default();
        api.print(&format!("{} {}", String::from("TestPlayer as GameEntity name:"), player_as_entity.entity_name));
        let mut super_player_as_player: TestPlayer = serde_json::from_value::<TestPlayer>(serde_json::to_value(&self.my_derived_player.clone()).unwrap_or_default()).unwrap_or_default();
        api.print(&format!("{} {}", String::from("SuperTestPlayer as TestPlayer health:"), super_player_as_player.health));
        let mut player_to_super_player: SuperTestPlayer = serde_json::from_value::<SuperTestPlayer>(serde_json::to_value(&self.my_player.clone()).unwrap_or_default()).unwrap_or_default();
        api.print(&format!("{} {}", String::from("TestPlayer as SuperTestPlayer (entity_name should be Hero OR default):"), player_to_super_player.entity_name));
        api.print(&format!("{} {}", String::from("TestPlayer as SuperTestPlayer (ability should be default/empty):"), player_to_super_player.special_ability));
        let mut super_player_roundtrip: SuperTestPlayer = self.my_derived_player.clone();
        api.print(&format!("{} {}", String::from("SuperTestPlayer roundtrip ability (expect Flight):"), super_player_roundtrip.special_ability));
        let mut entity_from_derived: GameEntity = serde_json::from_value::<GameEntity>(serde_json::to_value(&self.my_derived_player.clone()).unwrap_or_default()).unwrap_or_default();
        entity_from_derived.entity_name = String::from("DerivedEntity");
        api.print(&format!("{} {}", String::from("Entity from Derived, name changed (expect DerivedEntity):"), entity_from_derived.entity_name));
    }

    fn test_dynamic_containers_ops(&mut self, api: &mut ScriptApi<'_>, external_call: bool) {
        api.print(&String::from("--- Test Dynamic Containers Ops ---"));
        let mut arr_dyn_val_big: BigInt = self.dynamic_array_inferred.get(4u32 as usize).cloned().unwrap_or_default().as_str().map(|s| s.parse::<BigInt>().unwrap_or_default()).unwrap_or_else(|| BigInt::from(self.dynamic_array_inferred.get(4u32 as usize).cloned().unwrap_or_default().as_i64().unwrap_or_default()));
        arr_dyn_val_big = (arr_dyn_val_big.clone() * BigInt::from(2f32 as i32));
        api.print(&format!("{} {}", String::from("Dyn Array Elem Op (big):"), arr_dyn_val_big));
        let mut arr_dyn_val_decimal: f64 = self.dynamic_array_inferred.get(5u32 as usize).cloned().unwrap_or_default().as_f64().unwrap_or_default();
        arr_dyn_val_decimal = (arr_dyn_val_decimal + (0.05f64 as f64));
        api.print(&format!("{} {}", String::from("Dyn Array Elem Op (decimal):"), arr_dyn_val_decimal));
        let __idx__dynamic_array_inferred = 0u32 as usize;
        if self.dynamic_array_inferred.len() <= __idx__dynamic_array_inferred {
            self.dynamic_array_inferred.resize(__idx__dynamic_array_inferred + 1, json!(null));
        }
        self.dynamic_array_inferred[__idx__dynamic_array_inferred] = json!(self.typed_big_int);
        self.dynamic_array_inferred.push(json!(self.local_decimal));
        api.print(&format!("{} {}", String::from("Dyn Array Set (big):"), self.dynamic_array_inferred.get(0u32 as usize).cloned().unwrap_or_default().as_str().map(|s| s.parse::<BigInt>().unwrap_or_default()).unwrap_or_else(|| BigInt::from(self.dynamic_array_inferred.get(0u32 as usize).cloned().unwrap_or_default().as_i64().unwrap_or_default()))));
        api.print(&format!("{} {}", String::from("Dyn Array Push (decimal):"), self.dynamic_array_inferred.get((self.dynamic_array_inferred.len() - (1u32 as usize)) as usize).cloned().unwrap_or_default().as_f64().unwrap_or_default()));
        let mut map_dyn_val_big: BigInt = self.dynamic_map_inferred.get(String::from("gamma").as_str()).cloned().unwrap_or_default().as_str().map(|s| s.parse::<BigInt>().unwrap_or_default()).unwrap_or_else(|| BigInt::from(self.dynamic_map_inferred.get(String::from("gamma").as_str()).cloned().unwrap_or_default().as_i64().unwrap_or_default()));
        map_dyn_val_big = (map_dyn_val_big.clone() - BigInt::from_str(String::from("12345678901234567800").as_ref()).unwrap_or_default());
        api.print(&format!("{} {}", String::from("Dyn Map Elem Op (big):"), map_dyn_val_big));
        let mut map_dyn_val_decimal: f64 = self.dynamic_map_inferred.get(String::from("delta").as_str()).cloned().unwrap_or_default().as_f64().unwrap_or_default();
        map_dyn_val_decimal = (map_dyn_val_decimal * (2f64 as f64));
        api.print(&format!("{} {}", String::from("Dyn Map Elem Op (decimal):"), map_dyn_val_decimal));
        self.dynamic_map_inferred.insert(String::from("new_big"), json!(self.local_big_int));
        self.dynamic_map_inferred.insert(String::from("new_decimal"), json!(self.typed_decimal));
        api.print(&format!("{} {}", String::from("Dyn Map Set (new_big):"), self.dynamic_map_inferred.get(String::from("new_big").as_str()).cloned().unwrap_or_default().as_str().map(|s| s.parse::<BigInt>().unwrap_or_default()).unwrap_or_else(|| BigInt::from(self.dynamic_map_inferred.get(String::from("new_big").as_str()).cloned().unwrap_or_default().as_i64().unwrap_or_default()))));
        api.print(&format!("{} {}", String::from("Dyn Map Set (new_decimal):"), self.dynamic_map_inferred.get(String::from("new_decimal").as_str()).cloned().unwrap_or_default().as_f64().unwrap_or_default()));
        let mut dyn_map_numeric_key_big: HashMap<String, Value> = HashMap::<String, Value>::from([(self.typed_int_default.to_string(), json!(self.typed_big_int.clone()))]);
        api.print(&format!("{} {}", String::from("Dyn Map Num Key Big (20):"), dyn_map_numeric_key_big.get(String::from("20").as_str()).cloned().unwrap_or_default().as_str().map(|s| s.parse::<BigInt>().unwrap_or_default()).unwrap_or_else(|| BigInt::from(dyn_map_numeric_key_big.get(String::from("20").as_str()).cloned().unwrap_or_default().as_i64().unwrap_or_default()))));
        let mut dyn_map_numeric_key_decimal: HashMap<String, Value> = HashMap::<String, Value>::from([(self.typed_float_default.to_string(), json!(self.typed_decimal))]);
        api.print(&format!("{} {}", String::from("Dyn Map Num Key Dec (30.5):"), dyn_map_numeric_key_decimal.get(String::from("30.5").as_str()).cloned().unwrap_or_default().as_f64().unwrap_or_default()));
    }

    fn test_static_containers_ops(&mut self, api: &mut ScriptApi<'_>, external_call: bool) {
        api.print(&String::from("--- Test Static Containers Ops ---"));
        let mut arr_static_big_elem: BigInt = self.static_array_big_int.get(0u32 as usize).cloned().unwrap_or_default();
        arr_static_big_elem = (arr_static_big_elem.clone() + BigInt::from(50f32 as i32));
        api.print(&format!("{} {}", String::from("Static Array[big] Elem Op:"), arr_static_big_elem));
        let mut arr_static_decimal_elem: f64 = self.static_array_decimal.get(0u32 as usize).cloned().unwrap_or_default();
        arr_static_decimal_elem = (arr_static_decimal_elem - (0.05f64 as f64));
        api.print(&format!("{} {}", String::from("Static Array[decimal] Elem Op:"), arr_static_decimal_elem));
        let mut map_static_big_val: BigInt = self.static_map_string_big.get(String::from("large_num").as_str()).cloned().unwrap_or_default().as_str().and_then(|s| s.parse::<BigInt>().ok()).unwrap_or_else(|| BigInt::from(self.static_map_string_big.get(String::from("large_num").as_str()).cloned().unwrap_or_default().as_i64().unwrap_or_default()));
        map_static_big_val = (map_static_big_val.clone() * BigInt::from(2f32 as i32));
        api.print(&format!("{} {}", String::from("Static Map<string:big> Elem Op:"), map_static_big_val));
        let mut map_static_decimal_val: f64 = self.static_map_string_decimal.get(String::from("price").as_str()).cloned().unwrap_or_default().as_f64().unwrap_or_default();
        map_static_decimal_val = (map_static_decimal_val + (0.01f64 as f64));
        api.print(&format!("{} {}", String::from("Static Map<string:decimal> Elem Op:"), map_static_decimal_val));
        let mut big_to_uint8_key_float_val: f64 = 0.0f64;
        api.print(&format!("{} {}", String::from("Static Map<uint_8:float> Get with big key:"), big_to_uint8_key_float_val));
        let mut base_entity: GameEntity = serde_json::from_value::<GameEntity>(self.static_array_entities.get(0u32 as usize).cloned().unwrap_or_default()).unwrap_or_default();
        api.print(&format!("{} {}", String::from("Static Array[Entity] base_entity name:"), base_entity.entity_name));
        let mut player_as_entity_from_array: GameEntity = serde_json::from_value::<GameEntity>(self.static_array_entities.get(1u32 as usize).cloned().unwrap_or_default()).unwrap_or_default();
        api.print(&format!("{} {}", String::from("Static Array[Entity] player_as_entity_from_array name:"), player_as_entity_from_array.entity_name));
        let mut super_player_as_entity_from_array: GameEntity = serde_json::from_value::<GameEntity>(self.static_array_entities.get(2u32 as usize).cloned().unwrap_or_default()).unwrap_or_default();
        api.print(&format!("{} {}", String::from("Static Array[Entity] super_player_as_entity_from_array name:"), super_player_as_entity_from_array.entity_name));
        let mut casted_player: TestPlayer = serde_json::from_value::<TestPlayer>(serde_json::to_value(&serde_json::from_value::<GameEntity>(self.static_array_entities.get(1u32 as usize).cloned().unwrap_or_default()).unwrap_or_default().clone()).unwrap_or_default()).unwrap_or_default();
        api.print(&format!("{} {}", String::from("Static Array[Entity] Casted Player health:"), casted_player.health));
        let mut casted_super_player: SuperTestPlayer = serde_json::from_value::<SuperTestPlayer>(serde_json::to_value(&serde_json::from_value::<GameEntity>(self.static_array_entities.get(2u32 as usize).cloned().unwrap_or_default()).unwrap_or_default().clone()).unwrap_or_default()).unwrap_or_default();
        api.print(&format!("{} {}", String::from("Static Array[Entity] Casted SuperPlayer ability:"), casted_super_player.special_ability));
        let mut incompatible_downcast: SuperTestPlayer = serde_json::from_value::<SuperTestPlayer>(serde_json::to_value(&serde_json::from_value::<GameEntity>(self.static_array_entities.get(0u32 as usize).cloned().unwrap_or_default()).unwrap_or_default().clone()).unwrap_or_default()).unwrap_or_default();
        api.print(&format!("{} {}", String::from("Static Array[Entity] Incompatible Downcast name:"), incompatible_downcast.entity_name));
    }

}


impl ScriptObject for TypesTsScript {
    fn set_node_id(&mut self, id: Uuid) {
        self.base.id = id;
    }

    fn get_node_id(&self) -> Uuid {
        self.base.id
    }

    fn get_var(&self, var_id: u64) -> Option<Value> {
        VAR_GET_TABLE.get(&var_id).and_then(|f| f(self))
    }

    fn set_var(&mut self, var_id: u64, val: Value) -> Option<()> {
        VAR_SET_TABLE.get(&var_id).and_then(|f| f(self, val))
    }

    fn apply_exposed(&mut self, hashmap: &HashMap<u64, Value>) {
        for (var_id, val) in hashmap.iter() {
            if let Some(f) = VAR_APPLY_TABLE.get(var_id) {
                f(self, val);
            }
        }
    }

    fn call_function(
        &mut self,
        id: u64,
        api: &mut ScriptApi<'_>,
        params: &SmallVec<[Value; 3]>,
    ) {
        if let Some(f) = DISPATCH_TABLE.get(&id) {
            f(self, params, api);
        }
    }

    // Attributes

    fn attributes_of(&self, member: &str) -> Vec<String> {
        MEMBER_TO_ATTRIBUTES_MAP
            .get(member)
            .map(|attrs| attrs.iter().map(|s| s.to_string()).collect())
            .unwrap_or_default()
    }

    fn members_with(&self, attribute: &str) -> Vec<String> {
        ATTRIBUTE_TO_MEMBERS_MAP
            .get(attribute)
            .map(|members| members.iter().map(|s| s.to_string()).collect())
            .unwrap_or_default()
    }

    fn has_attribute(&self, member: &str, attribute: &str) -> bool {
        MEMBER_TO_ATTRIBUTES_MAP
            .get(member)
            .map(|attrs| attrs.iter().any(|a| *a == attribute))
            .unwrap_or(false)
    }
}

// =========================== Static PHF Dispatch Tables ===========================

static VAR_GET_TABLE: phf::Map<u64, fn(&TypesTsScript) -> Option<Value>> =
    phf::phf_map! {
        2485169244931714667u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.untyped_num_default))
                    },
        1504910378154860307u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.typed_int_default))
                    },
        658168785591864834u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.typed_int_8))
                    },
        17966784340007944020u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.typed_int_64))
                    },
        3252444866660192402u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.typed_uint_16))
                    },
        5074350817013894852u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.typed_float_default))
                    },
        8575771357858329841u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.typed_float_64))
                    },
        8584268266216124416u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.typed_big_int))
                    },
        16018926697858484043u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.typed_decimal))
                    },
        2918741743342288797u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.typed_string))
                    },
        8500958789799191182u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.local_int))
                    },
        3383146763946373218u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.testVector))
                    },
        3852818006577474432u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.gameEntity))
                    },
        16633751062644872864u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.testPlayer))
                    },
        17391103494345287493u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.superTestPlayer))
                    },
        6760292584569910041u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.my_base_entity))
                    },
        15631901558265132697u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.my_player))
                    },
        1107408580180678471u64 => |script: &TypesTsScript| -> Option<Value> {
                        Some(json!(script.my_derived_player))
                    },
        397621861165125654u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.dynamic_array_inferred).unwrap_or_default())
                            },
        7350485059281851515u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.dynamic_map_inferred).unwrap_or_default())
                            },
        8275284063617525799u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.dynamic_array_annotated).unwrap_or_default())
                            },
        5183367058847120760u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.dynamic_map_annotated).unwrap_or_default())
                            },
        5337103969028899u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_int).unwrap_or_default())
                            },
        11147407808312781560u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_uint_16).unwrap_or_default())
                            },
        11774070694902202195u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_string).unwrap_or_default())
                            },
        12618829247944308375u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_float_64).unwrap_or_default())
                            },
        11622495865823915786u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_big_int).unwrap_or_default())
                            },
        15605525470769910961u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_decimal).unwrap_or_default())
                            },
        10539066375271246519u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_map_string_int_64).unwrap_or_default())
                            },
        13676620148509593656u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_map_int_string).unwrap_or_default())
                            },
        15879637269458870541u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_map_uint_8_float).unwrap_or_default())
                            },
        13381633098612637663u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_map_string_big).unwrap_or_default())
                            },
        2532243207680400902u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_map_string_decimal).unwrap_or_default())
                            },
        9044830729489509861u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_entities).unwrap_or_default())
                            },
        1181354728222443296u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_players).unwrap_or_default())
                            },
        16255415596013162047u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_map_players).unwrap_or_default())
                            },
        937814722116048519u64 => |script: &TypesTsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_map_super_players).unwrap_or_default())
                            },

    };

static VAR_SET_TABLE: phf::Map<u64, fn(&mut TypesTsScript, Value) -> Option<()>> =
    phf::phf_map! {
        2485169244931714667u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_f64() {
                                script.untyped_num_default = v as f64;
                                return Some(());
                            }
                            None
                        },
        1504910378154860307u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_f64() {
                                script.typed_int_default = v as f64;
                                return Some(());
                            }
                            None
                        },
        658168785591864834u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_f64() {
                                script.typed_int_8 = v as f64;
                                return Some(());
                            }
                            None
                        },
        17966784340007944020u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_f64() {
                                script.typed_int_64 = v as f64;
                                return Some(());
                            }
                            None
                        },
        3252444866660192402u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_f64() {
                                script.typed_uint_16 = v as f64;
                                return Some(());
                            }
                            None
                        },
        5074350817013894852u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_f64() {
                                script.typed_float_default = v as f64;
                                return Some(());
                            }
                            None
                        },
        8575771357858329841u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_f64() {
                                script.typed_float_64 = v as f64;
                                return Some(());
                            }
                            None
                        },
        8584268266216124416u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_str() {
                                script.typed_big_int = v.parse::<BigInt>().unwrap();
                                return Some(());
                            }
                            None
                        },
        16018926697858484043u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_f64() {
                                script.typed_decimal = v as f64;
                                return Some(());
                            }
                            None
                        },
        2918741743342288797u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_str() {
                                script.typed_string = v.to_string();
                                return Some(());
                            }
                            None
                        },
        8500958789799191182u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_f64() {
                                script.local_int = v as f64;
                                return Some(());
                            }
                            None
                        },
        3383146763946373218u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Ok(v) = serde_json::from_value::<TestVector>(val) {
                                script.testVector = v;
                                return Some(());
                            }
                            None
                        },
        3852818006577474432u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Ok(v) = serde_json::from_value::<GameEntity>(val) {
                                script.gameEntity = v;
                                return Some(());
                            }
                            None
                        },
        16633751062644872864u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Ok(v) = serde_json::from_value::<TestPlayer>(val) {
                                script.testPlayer = v;
                                return Some(());
                            }
                            None
                        },
        17391103494345287493u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Ok(v) = serde_json::from_value::<SuperTestPlayer>(val) {
                                script.superTestPlayer = v;
                                return Some(());
                            }
                            None
                        },
        6760292584569910041u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Ok(v) = serde_json::from_value::<GameEntity>(val) {
                                script.my_base_entity = v;
                                return Some(());
                            }
                            None
                        },
        15631901558265132697u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Ok(v) = serde_json::from_value::<TestPlayer>(val) {
                                script.my_player = v;
                                return Some(());
                            }
                            None
                        },
        1107408580180678471u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                            if let Ok(v) = serde_json::from_value::<SuperTestPlayer>(val) {
                                script.my_derived_player = v;
                                return Some(());
                            }
                            None
                        },
        397621861165125654u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_array() {
                                        script.dynamic_array_inferred = v.clone();
                                        return Some(());
                                    }
                                    None
                                },
        7350485059281851515u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.dynamic_map_inferred = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        8275284063617525799u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_array() {
                                        script.dynamic_array_annotated = v.clone();
                                        return Some(());
                                    }
                                    None
                                },
        5183367058847120760u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.dynamic_map_annotated = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        5337103969028899u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<f64>>(val) {
                                        script.static_array_int = vec_typed;
                                        return Some(());
                                    }
                                    None
                                },
        11147407808312781560u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<f64>>(val) {
                                        script.static_array_uint_16 = vec_typed;
                                        return Some(());
                                    }
                                    None
                                },
        11774070694902202195u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<String>>(val) {
                                        script.static_array_string = vec_typed;
                                        return Some(());
                                    }
                                    None
                                },
        12618829247944308375u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<f64>>(val) {
                                        script.static_array_float_64 = vec_typed;
                                        return Some(());
                                    }
                                    None
                                },
        11622495865823915786u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<BigInt>>(val) {
                                        script.static_array_big_int = vec_typed;
                                        return Some(());
                                    }
                                    None
                                },
        15605525470769910961u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<f64>>(val) {
                                        script.static_array_decimal = vec_typed;
                                        return Some(());
                                    }
                                    None
                                },
        10539066375271246519u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.static_map_string_int_64 = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        13676620148509593656u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.static_map_int_string = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        15879637269458870541u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.static_map_uint_8_float = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        13381633098612637663u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.static_map_string_big = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        2532243207680400902u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.static_map_string_decimal = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        9044830729489509861u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<GameEntity>>(val) {
                                        script.static_array_entities = vec_typed.into_iter().map(|x| serde_json::to_value(x).unwrap_or_default()).collect();
                                        return Some(());
                                    }
                                    None
                                },
        1181354728222443296u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<TestPlayer>>(val) {
                                        script.static_array_players = vec_typed.into_iter().map(|x| serde_json::to_value(x).unwrap_or_default()).collect();
                                        return Some(());
                                    }
                                    None
                                },
        16255415596013162047u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.static_map_players = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        937814722116048519u64 => |script: &mut TypesTsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.static_map_super_players = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },

    };

static VAR_APPLY_TABLE: phf::Map<u64, fn(&mut TypesTsScript, &Value)> =
    phf::phf_map! {

    };

static DISPATCH_TABLE: phf::Map<
    u64,
    fn(&mut TypesTsScript, &[Value], &mut ScriptApi<'_>),
> = phf::phf_map! {
        8498657248953742794u64 => | script: &mut TypesTsScript, params: &[Value], api: &mut ScriptApi<'_>| {
            script.test_primitive_operations(api, true);
        },
        7792328159662995076u64 => | script: &mut TypesTsScript, params: &[Value], api: &mut ScriptApi<'_>| {
            script.test_explicit_casting(api, true);
        },
        8784565498339593560u64 => | script: &mut TypesTsScript, params: &[Value], api: &mut ScriptApi<'_>| {
            script.test_assignments(api, true);
        },
        6891749365949355100u64 => | script: &mut TypesTsScript, params: &[Value], api: &mut ScriptApi<'_>| {
            script.test_struct_inheritance_and_casting(api, true);
        },
        15775999022398286627u64 => | script: &mut TypesTsScript, params: &[Value], api: &mut ScriptApi<'_>| {
            script.test_dynamic_containers_ops(api, true);
        },
        8968113419297778246u64 => | script: &mut TypesTsScript, params: &[Value], api: &mut ScriptApi<'_>| {
            script.test_static_containers_ops(api, true);
        },

    };
