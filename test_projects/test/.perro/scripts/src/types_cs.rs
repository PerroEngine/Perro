#![allow(improper_ctypes_definitions)]
#![allow(unused)]

use std::{
    any::Any,
    cell::RefCell,
    collections::HashMap,
    ops::{Deref, DerefMut},
    rc::Rc,
    str::FromStr,
};

use num_bigint::BigInt;
use phf::{phf_map, Map};
use rust_decimal::Decimal;
use rust_decimal::prelude::{FromPrimitive, ToPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use smallvec::{smallvec, SmallVec};
use uuid::Uuid;

use perro_core::prelude::*;

//=======================================;
// Auto Generated by Perro Transpiler [Any further edits to this file will be overwritten on next transile];
//=======================================;

// ========================================================================
// TypesCs - Main Script Structure
// ========================================================================

static MEMBER_TO_ATTRIBUTES_MAP: Map<&'static str, &'static [&'static str]> = phf_map! {
};

static ATTRIBUTE_TO_MEMBERS_MAP: Map<&'static str, &'static [&'static str]> = phf_map! {
};

pub struct TypesCsScript {
    base: Node2D,
    untyped_num_default: i32,
    typed_int_default: i32,
    typed_int_8: i8,
    typed_int_64: i64,
    typed_uint_16: u16,
    typed_float_default: f32,
    typed_float_64: f64,
    typed_big_int: BigInt,
    typed_decimal: Decimal,
    typed_string: String,
    local_int: i32,
    local_uint_8: u8,
    local_float: f32,
    local_string: String,
    local_big_int: BigInt,
    local_decimal: Decimal,
    my_base_entity: GameEntity,
    my_player: TestPlayer,
    other_player: TestPlayer,
    my_derived_player: SuperTestPlayer,
    my_derived_player_var: SuperTestPlayer,
    dynamic_array_inferred: Vec<Value>,
    dynamic_map_inferred: HashMap<String, Value>,
    dynamic_array_annotated: Vec<Value>,
    dynamic_map_annotated: HashMap<String, Value>,
    static_array_int: Vec<i32>,
    static_array_uint_16: Vec<u16>,
    static_array_string: Vec<String>,
    static_array_float_64: Vec<f64>,
    static_array_big_int: Vec<BigInt>,
    static_array_decimal: Vec<Decimal>,
    static_map_string_int_64: HashMap<String, Value>,
    static_map_int_string: HashMap<String, Value>,
    static_map_uint_8_float: HashMap<String, Value>,
    static_map_string_big: HashMap<String, Value>,
    static_map_string_decimal: HashMap<String, Value>,
    static_array_entities: Vec<Value>,
    static_array_players: Vec<Value>,
    static_map_players: HashMap<String, Value>,
    static_map_super_players: HashMap<String, Value>,
}

// ========================================================================
// TypesCs - Creator Function (FFI Entry Point)
// ========================================================================

#[unsafe(no_mangle)]
pub extern "C" fn types_cs_create_script() -> *mut dyn ScriptObject {
    let base = Node2D::new("TypesCs");
    let untyped_num_default = 0i32;
    let typed_int_default = 0i32;
    let typed_int_8 = 0i8;
    let typed_int_64 = 0i64;
    let typed_uint_16 = 0u16;
    let typed_float_default = 0.0f32;
    let typed_float_64 = 0.0f64;
    let typed_big_int = BigInt::from_str("0").unwrap();
    let typed_decimal = Decimal::from_str("0").unwrap();
    let typed_string = String::new();
    let local_int = 0i32;
    let local_uint_8 = 0u8;
    let local_float = 0.0f32;
    let local_string = String::new();
    let local_big_int = BigInt::from_str("0").unwrap();
    let local_decimal = Decimal::from_str("0").unwrap();
    let my_base_entity = Default::default();
    let my_player = Default::default();
    let other_player = Default::default();
    let my_derived_player = Default::default();
    let my_derived_player_var = Default::default();
    let dynamic_array_inferred = Vec::new();
    let dynamic_map_inferred = HashMap::new();
    let dynamic_array_annotated = Vec::new();
    let dynamic_map_annotated = HashMap::new();
    let static_array_int = Vec::new();
    let static_array_uint_16 = Vec::new();
    let static_array_string = Vec::new();
    let static_array_float_64 = Vec::new();
    let static_array_big_int = Vec::new();
    let static_array_decimal = Vec::new();
    let static_map_string_int_64 = HashMap::new();
    let static_map_int_string = HashMap::new();
    let static_map_uint_8_float = HashMap::new();
    let static_map_string_big = HashMap::new();
    let static_map_string_decimal = HashMap::new();
    let static_array_entities = Vec::new();
    let static_array_players = Vec::new();
    let static_map_players = HashMap::new();
    let static_map_super_players = HashMap::new();

    Box::into_raw(Box::new(TypesCsScript {
        base,
        untyped_num_default,
        typed_int_default,
        typed_int_8,
        typed_int_64,
        typed_uint_16,
        typed_float_default,
        typed_float_64,
        typed_big_int,
        typed_decimal,
        typed_string,
        local_int,
        local_uint_8,
        local_float,
        local_string,
        local_big_int,
        local_decimal,
        my_base_entity,
        my_player,
        other_player,
        my_derived_player,
        my_derived_player_var,
        dynamic_array_inferred,
        dynamic_map_inferred,
        dynamic_array_annotated,
        dynamic_map_annotated,
        static_array_int,
        static_array_uint_16,
        static_array_string,
        static_array_float_64,
        static_array_big_int,
        static_array_decimal,
        static_map_string_int_64,
        static_map_int_string,
        static_map_uint_8_float,
        static_map_string_big,
        static_map_string_decimal,
        static_array_entities,
        static_array_players,
        static_map_players,
        static_map_super_players,
    })) as *mut dyn ScriptObject
}

// ========================================================================
// Supporting Struct Definitions
// ========================================================================

#[derive(Default, Debug, Clone, Serialize, Deserialize)]
pub struct TestVector {
    pub x: f32,
    pub y: f32,
}

impl std::fmt::Display for TestVector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{ ")?;
        write!(f, "x: {:?}, ", self.x)?;
        write!(f, "y: {:?} ", self.y)?;
        write!(f, "}}")
    }
}



#[derive(Default, Debug, Clone, Serialize, Deserialize)]
pub struct GameEntity {
    pub entity_id: i32,
    pub entity_name: String,
    pub entity_type: String,
}

impl std::fmt::Display for GameEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{ ")?;
        write!(f, "entity_id: {:?}, ", self.entity_id)?;
        write!(f, "entity_name: {:?}, ", self.entity_name)?;
        write!(f, "entity_type: {:?} ", self.entity_type)?;
        write!(f, "}}")
    }
}



#[derive(Default, Debug, Clone, Serialize, Deserialize)]
pub struct TestPlayer {
    pub base: GameEntity,
    pub pos: TestVector,
    pub health: f32,
    pub mana: i8,
}

impl std::fmt::Display for TestPlayer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{ ")?;
        // Flatten base Display
        let base_str = format!("{}", self.base);
        let base_inner = base_str.trim_matches(|c| c == '{' || c == '}').trim();
        if !base_inner.is_empty() {
            write!(f, "{}", base_inner)?;
            write!(f, ", ")?;
        }
        write!(f, "pos: {:?}, ", self.pos)?;
        write!(f, "health: {:?}, ", self.health)?;
        write!(f, "mana: {:?} ", self.mana)?;
        write!(f, "}}")
    }
}

impl std::ops::Deref for TestPlayer {
    type Target = GameEntity;
    fn deref(&self) -> &Self::Target { &self.base }
}

impl std::ops::DerefMut for TestPlayer {
    fn deref_mut(&mut self) -> &mut Self::Target { &mut self.base }
}



#[derive(Default, Debug, Clone, Serialize, Deserialize)]
pub struct SuperTestPlayer {
    pub base: TestPlayer,
    pub special_ability: String,
    pub energy_core: Decimal,
}

impl std::fmt::Display for SuperTestPlayer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{ ")?;
        // Flatten base Display
        let base_str = format!("{}", self.base);
        let base_inner = base_str.trim_matches(|c| c == '{' || c == '}').trim();
        if !base_inner.is_empty() {
            write!(f, "{}", base_inner)?;
            write!(f, ", ")?;
        }
        write!(f, "special_ability: {:?}, ", self.special_ability)?;
        write!(f, "energy_core: {:?} ", self.energy_core)?;
        write!(f, "}}")
    }
}

impl std::ops::Deref for SuperTestPlayer {
    type Target = TestPlayer;
    fn deref(&self) -> &Self::Target { &self.base }
}

impl std::ops::DerefMut for SuperTestPlayer {
    fn deref_mut(&mut self) -> &mut Self::Target { &mut self.base }
}



// ========================================================================
// TypesCs - Script Init & Update Implementation
// ========================================================================

impl Script for TypesCsScript {
    fn init(&mut self, api: &mut ScriptApi<'_>) {
        api.print(&String::from("--- START CSharp MEGA TEST SUITE ---"));
        self.TestPrimitiveOperations(api, false);
        self.TestExplicitCasting(api, false);
        self.TestAssignments(api, false);
        self.TestStructInheritanceAndCasting(api, false);
        self.TestDynamicContainersOps(api, false);
        self.TestStaticContainersOps(api, false);
        api.print(&String::from("--- ALL CSharp TESTS COMPLETE ---"));
    }

    fn update(&mut self, api: &mut ScriptApi<'_>) {
        self.TestPrimitiveOperations(api, false);
        self.TestExplicitCasting(api, false);
        self.TestAssignments(api, false);
        self.TestStructInheritanceAndCasting(api, false);
        self.TestDynamicContainersOps(api, false);
        self.TestStaticContainersOps(api, false);
    }

}

// ========================================================================
// TypesCs - Script-Defined Methods
// ========================================================================

impl TypesCsScript {
    fn TestPrimitiveOperations(&mut self, api: &mut ScriptApi<'_>, external_call: bool) {
        api.print(&String::from("--- Test Primitive Operations ---"));
        let mut res_int: i32 = 0i32;
        let mut res_big: BigInt = BigInt::from_str("0").unwrap();
        let mut res_decimal: Decimal = Decimal::from_str("0").unwrap();
        let mut res_big_var: BigInt = BigInt::from_str("0").unwrap();
        let mut res_decimal_var: Decimal = Decimal::from_str("0").unwrap();
        let mut prom_float_big: f64 = 0.0f64;
        let mut prom_float_decimal: f64 = 0.0f64;
        let mut prom_big_int: BigInt = BigInt::from_str("0").unwrap();
    }

    fn TestExplicitCasting(&mut self, api: &mut ScriptApi<'_>, external_call: bool) {
        api.print(&String::from("--- Test Explicit Casting ---"));
        let mut int64_to_big: BigInt = BigInt::from_str("0").unwrap();
        let mut big_to_int: i32 = 0i32;
        let mut float_to_decimal: Decimal = Decimal::from_str("0").unwrap();
        let mut decimal_to_float_64: f64 = 0.0f64;
        let mut string_to_uint16: u16 = 0u16;
        let mut big_to_string: String = String::new();
        let mut dyn_val_big: BigInt = BigInt::from_str("0").unwrap();
        let mut dyn_val_decimal: Decimal = Decimal::from_str("0").unwrap();
        let mut casted_and_op_big: BigInt = BigInt::from_str("0").unwrap();
    }

    fn TestAssignments(&mut self, api: &mut ScriptApi<'_>, external_call: bool) {
        api.print(&String::from("--- Test Assignments (Simple & Compound) ---"));
        let mut assign_big_lit: BigInt = BigInt::from_str("0").unwrap();
        let mut assign_decimal_var: Decimal = Decimal::from_str("0").unwrap();
        let mut comp_big: BigInt = BigInt::from_str("0").unwrap();
        comp_big += BigInt::from_str("50").unwrap();
        let mut comp_decimal: Decimal = Decimal::from_str("0").unwrap();
        comp_decimal -= Decimal::from_str("5.5").unwrap();
        let mut assign_prom_decimal: Decimal = Decimal::from_str("0").unwrap();
    }

    fn TestStructInheritanceAndCasting(&mut self, api: &mut ScriptApi<'_>, external_call: bool) {
        api.print(&String::from("--- Test Struct Inheritance & Casting ---"));
        self.my_derived_player.health = (self.my_derived_player.health - 10.0f32);
        self.my_derived_player.pos.x = (self.my_derived_player.pos.x + 1.0f32);
        self.my_derived_player.entity_type = String::from("ElitePlayer");
        let mut player_as_entity: GameEntity = Default::default();
        let mut super_player_as_player: TestPlayer = Default::default();
        let mut player_to_super_player: SuperTestPlayer = Default::default();
        let mut super_player_roundtrip: SuperTestPlayer = Default::default();
        let mut entity_from_derived: GameEntity = Default::default();
        entity_from_derived.entity_name = String::from("DerivedEntity");
    }

    fn TestDynamicContainersOps(&mut self, api: &mut ScriptApi<'_>, external_call: bool) {
        api.print(&String::from("--- Test Dynamic Containers Ops ---"));
        let mut arr_dyn_val_big: BigInt = BigInt::from_str("0").unwrap();
        arr_dyn_val_big *= BigInt::from_str("2").unwrap();
        let mut arr_dyn_val_decimal: Decimal = Decimal::from_str("0").unwrap();
        arr_dyn_val_decimal += { let tmp: Decimal = Decimal::from_str("0.05").unwrap(); tmp };
        let __idx__dynamic_array_inferred = 0u32 as usize;
        if self.dynamic_array_inferred.len() <= __idx__dynamic_array_inferred {
            self.dynamic_array_inferred.resize(__idx__dynamic_array_inferred + 1, json!(null));
        }
        self.dynamic_array_inferred[__idx__dynamic_array_inferred] = json!(self.typed_big_int);
        let __dynamic_array_inferred_idx = (self.dynamic_array_inferred.len() - (1u32 as usize)) as usize;
        if self.dynamic_array_inferred.len() <= __dynamic_array_inferred_idx {
            self.dynamic_array_inferred.resize(__dynamic_array_inferred_idx + 1, json!(null));
        }
self.dynamic_array_inferred[__dynamic_array_inferred_idx] = json!(self.local_decimal);
        let mut map_dyn_val_big: BigInt = BigInt::from_str("0").unwrap();
        map_dyn_val_big -= BigInt::from_str(String::from("12345678901234567800").as_ref()).unwrap_or_default();
        let mut map_dyn_val_decimal: Decimal = Decimal::from_str("0").unwrap();
        map_dyn_val_decimal *= Decimal::from_str("2").unwrap();
        self.dynamic_map_inferred.insert(String::from("new_big"), json!(self.local_big_int));
        self.dynamic_map_inferred.insert(String::from("new_decimal"), json!(self.typed_decimal));
        let mut dyn_map_numeric_key_big: HashMap<String, Value> = HashMap::new();
        let mut dyn_map_numeric_key_decimal: HashMap<String, Value> = HashMap::new();
    }

    fn TestStaticContainersOps(&mut self, api: &mut ScriptApi<'_>, external_call: bool) {
        api.print(&String::from("--- Test Static Containers Ops ---"));
        let mut arr_static_big_elem: BigInt = BigInt::from_str("0").unwrap();
        arr_static_big_elem += BigInt::from_str("50").unwrap();
        let mut arr_static_decimal_elem: Decimal = Decimal::from_str("0").unwrap();
        arr_static_decimal_elem -= Decimal::from_str("0.05").unwrap();
        let mut map_static_big_val: BigInt = BigInt::from_str("0").unwrap();
        map_static_big_val *= BigInt::from_str("2").unwrap();
        let mut map_static_decimal_val: Decimal = Decimal::from_str("0").unwrap();
        map_static_decimal_val += { let tmp: Decimal = Decimal::from_str("0.01").unwrap(); tmp };
        let mut big_to_uint8_key: u8 = 0u8;
        let mut big_to_uint8_key_float_val: f32 = 0.0f32;
        let mut base_entity: GameEntity = Default::default();
        let mut player_as_entity_from_array: GameEntity = Default::default();
        let mut super_player_as_entity_from_array: GameEntity = Default::default();
        let mut casted_player: TestPlayer = Default::default();
        let mut casted_super_player: SuperTestPlayer = Default::default();
        let mut incompatible_downcast: SuperTestPlayer = Default::default();
    }

}


impl ScriptObject for TypesCsScript {
    fn set_node_id(&mut self, id: Uuid) {
        self.base.id = id;
    }

    fn get_node_id(&self) -> Uuid {
        self.base.id
    }

    fn get_var(&self, var_id: u64) -> Option<Value> {
        VAR_GET_TABLE.get(&var_id).and_then(|f| f(self))
    }

    fn set_var(&mut self, var_id: u64, val: Value) -> Option<()> {
        VAR_SET_TABLE.get(&var_id).and_then(|f| f(self, val))
    }

    fn apply_exposed(&mut self, hashmap: &HashMap<u64, Value>) {
        for (var_id, val) in hashmap.iter() {
            if let Some(f) = VAR_APPLY_TABLE.get(var_id) {
                f(self, val);
            }
        }
    }

    fn call_function(
        &mut self,
        id: u64,
        api: &mut ScriptApi<'_>,
        params: &SmallVec<[Value; 3]>,
    ) -> Value {
        if let Some(f) = DISPATCH_TABLE.get(&id) {
            f(self, params, api);
        }
        Value::Null
    }

    // Attributes

    fn attributes_of(&self, member: &str) -> Vec<String> {
        MEMBER_TO_ATTRIBUTES_MAP
            .get(member)
            .map(|attrs| attrs.iter().map(|s| s.to_string()).collect())
            .unwrap_or_default()
    }

    fn members_with(&self, attribute: &str) -> Vec<String> {
        ATTRIBUTE_TO_MEMBERS_MAP
            .get(attribute)
            .map(|members| members.iter().map(|s| s.to_string()).collect())
            .unwrap_or_default()
    }

    fn has_attribute(&self, member: &str, attribute: &str) -> bool {
        MEMBER_TO_ATTRIBUTES_MAP
            .get(member)
            .map(|attrs| attrs.iter().any(|a| *a == attribute))
            .unwrap_or(false)
    }
}

// =========================== Static PHF Dispatch Tables ===========================

static VAR_GET_TABLE: phf::Map<u64, fn(&TypesCsScript) -> Option<Value>> =
    phf::phf_map! {
        2485169244931714667u64 => |script: &TypesCsScript| -> Option<Value> {
                        Some(json!(script.untyped_num_default))
                    },
        1504910378154860307u64 => |script: &TypesCsScript| -> Option<Value> {
                        Some(json!(script.typed_int_default))
                    },
        658168785591864834u64 => |script: &TypesCsScript| -> Option<Value> {
                        Some(json!(script.typed_int_8))
                    },
        17966784340007944020u64 => |script: &TypesCsScript| -> Option<Value> {
                        Some(json!(script.typed_int_64))
                    },
        3252444866660192402u64 => |script: &TypesCsScript| -> Option<Value> {
                        Some(json!(script.typed_uint_16))
                    },
        5074350817013894852u64 => |script: &TypesCsScript| -> Option<Value> {
                        Some(json!(script.typed_float_default))
                    },
        8575771357858329841u64 => |script: &TypesCsScript| -> Option<Value> {
                        Some(json!(script.typed_float_64))
                    },
        8584268266216124416u64 => |script: &TypesCsScript| -> Option<Value> {
                        Some(json!(script.typed_big_int))
                    },
        16018926697858484043u64 => |script: &TypesCsScript| -> Option<Value> {
                        Some(json!(script.typed_decimal))
                    },
        2918741743342288797u64 => |script: &TypesCsScript| -> Option<Value> {
                        Some(json!(script.typed_string))
                    },
        6760292584569910041u64 => |script: &TypesCsScript| -> Option<Value> {
                        Some(json!(script.my_base_entity))
                    },
        15631901558265132697u64 => |script: &TypesCsScript| -> Option<Value> {
                        Some(json!(script.my_player))
                    },
        1107408580180678471u64 => |script: &TypesCsScript| -> Option<Value> {
                        Some(json!(script.my_derived_player))
                    },
        397621861165125654u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.dynamic_array_inferred).unwrap_or_default())
                            },
        7350485059281851515u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.dynamic_map_inferred).unwrap_or_default())
                            },
        8275284063617525799u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.dynamic_array_annotated).unwrap_or_default())
                            },
        5183367058847120760u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.dynamic_map_annotated).unwrap_or_default())
                            },
        5337103969028899u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_int).unwrap_or_default())
                            },
        11147407808312781560u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_uint_16).unwrap_or_default())
                            },
        11774070694902202195u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_string).unwrap_or_default())
                            },
        12618829247944308375u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_float_64).unwrap_or_default())
                            },
        11622495865823915786u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_big_int).unwrap_or_default())
                            },
        15605525470769910961u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_decimal).unwrap_or_default())
                            },
        10539066375271246519u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_map_string_int_64).unwrap_or_default())
                            },
        13676620148509593656u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_map_int_string).unwrap_or_default())
                            },
        15879637269458870541u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_map_uint_8_float).unwrap_or_default())
                            },
        13381633098612637663u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_map_string_big).unwrap_or_default())
                            },
        2532243207680400902u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_map_string_decimal).unwrap_or_default())
                            },
        9044830729489509861u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_entities).unwrap_or_default())
                            },
        1181354728222443296u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_array_players).unwrap_or_default())
                            },
        16255415596013162047u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_map_players).unwrap_or_default())
                            },
        937814722116048519u64 => |script: &TypesCsScript| -> Option<Value> {
                                Some(serde_json::to_value(&script.static_map_super_players).unwrap_or_default())
                            },

    };

static VAR_SET_TABLE: phf::Map<u64, fn(&mut TypesCsScript, Value) -> Option<()>> =
    phf::phf_map! {
        2485169244931714667u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_i64() {
                                script.untyped_num_default = v as i32;
                                return Some(());
                            }
                            None
                        },
        1504910378154860307u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_i64() {
                                script.typed_int_default = v as i32;
                                return Some(());
                            }
                            None
                        },
        658168785591864834u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_i64() {
                                script.typed_int_8 = v as i8;
                                return Some(());
                            }
                            None
                        },
        17966784340007944020u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_i64() {
                                script.typed_int_64 = v as i64;
                                return Some(());
                            }
                            None
                        },
        3252444866660192402u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_u64() {
                                script.typed_uint_16 = v as u16;
                                return Some(());
                            }
                            None
                        },
        5074350817013894852u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_f64() {
                                script.typed_float_default = v as f32;
                                return Some(());
                            }
                            None
                        },
        8575771357858329841u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_f64() {
                                script.typed_float_64 = v as f64;
                                return Some(());
                            }
                            None
                        },
        8584268266216124416u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_str() {
                                script.typed_big_int = v.parse::<BigInt>().unwrap();
                                return Some(());
                            }
                            None
                        },
        16018926697858484043u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_str() {
                                script.typed_decimal = v.parse::<Decimal>().unwrap();
                                return Some(());
                            }
                            None
                        },
        2918741743342288797u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                            if let Some(v) = val.as_str() {
                                script.typed_string = v.to_string();
                                return Some(());
                            }
                            None
                        },
        6760292584569910041u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                            if let Ok(v) = serde_json::from_value::<GameEntity>(val) {
                                script.my_base_entity = v;
                                return Some(());
                            }
                            None
                        },
        15631901558265132697u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                            if let Ok(v) = serde_json::from_value::<TestPlayer>(val) {
                                script.my_player = v;
                                return Some(());
                            }
                            None
                        },
        1107408580180678471u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                            if let Ok(v) = serde_json::from_value::<SuperTestPlayer>(val) {
                                script.my_derived_player = v;
                                return Some(());
                            }
                            None
                        },
        397621861165125654u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_array() {
                                        script.dynamic_array_inferred = v.clone();
                                        return Some(());
                                    }
                                    None
                                },
        7350485059281851515u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.dynamic_map_inferred = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        8275284063617525799u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_array() {
                                        script.dynamic_array_annotated = v.clone();
                                        return Some(());
                                    }
                                    None
                                },
        5183367058847120760u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.dynamic_map_annotated = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        5337103969028899u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<i32>>(val) {
                                        script.static_array_int = vec_typed;
                                        return Some(());
                                    }
                                    None
                                },
        11147407808312781560u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<u16>>(val) {
                                        script.static_array_uint_16 = vec_typed;
                                        return Some(());
                                    }
                                    None
                                },
        11774070694902202195u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<String>>(val) {
                                        script.static_array_string = vec_typed;
                                        return Some(());
                                    }
                                    None
                                },
        12618829247944308375u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<f64>>(val) {
                                        script.static_array_float_64 = vec_typed;
                                        return Some(());
                                    }
                                    None
                                },
        11622495865823915786u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<BigInt>>(val) {
                                        script.static_array_big_int = vec_typed;
                                        return Some(());
                                    }
                                    None
                                },
        15605525470769910961u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<Decimal>>(val) {
                                        script.static_array_decimal = vec_typed;
                                        return Some(());
                                    }
                                    None
                                },
        10539066375271246519u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.static_map_string_int_64 = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        13676620148509593656u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.static_map_int_string = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        15879637269458870541u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.static_map_uint_8_float = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        13381633098612637663u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.static_map_string_big = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        2532243207680400902u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.static_map_string_decimal = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        9044830729489509861u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<GameEntity>>(val) {
                                        script.static_array_entities = vec_typed.into_iter().map(|x| serde_json::to_value(x).unwrap_or_default()).collect();
                                        return Some(());
                                    }
                                    None
                                },
        1181354728222443296u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Ok(vec_typed) = serde_json::from_value::<Vec<TestPlayer>>(val) {
                                        script.static_array_players = vec_typed.into_iter().map(|x| serde_json::to_value(x).unwrap_or_default()).collect();
                                        return Some(());
                                    }
                                    None
                                },
        16255415596013162047u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.static_map_players = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },
        937814722116048519u64 => |script: &mut TypesCsScript, val: Value| -> Option<()> {
                                    if let Some(v) = val.as_object() {
                                        script.static_map_super_players = v.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
                                        return Some(());
                                    }
                                    None
                                },

    };

static VAR_APPLY_TABLE: phf::Map<u64, fn(&mut TypesCsScript, &Value)> =
    phf::phf_map! {

    };

static DISPATCH_TABLE: phf::Map<
    u64,
    fn(&mut TypesCsScript, &[Value], &mut ScriptApi<'_>),
> = phf::phf_map! {
        577031581147095992u64 => | script: &mut TypesCsScript, params: &[Value], api: &mut ScriptApi<'_>| {
            script.TestPrimitiveOperations(api, true);
        },
        16055571004484687222u64 => | script: &mut TypesCsScript, params: &[Value], api: &mut ScriptApi<'_>| {
            script.TestExplicitCasting(api, true);
        },
        9173867575366100121u64 => | script: &mut TypesCsScript, params: &[Value], api: &mut ScriptApi<'_>| {
            script.TestAssignments(api, true);
        },
        4352772660019329826u64 => | script: &mut TypesCsScript, params: &[Value], api: &mut ScriptApi<'_>| {
            script.TestStructInheritanceAndCasting(api, true);
        },
        1969898220840237834u64 => | script: &mut TypesCsScript, params: &[Value], api: &mut ScriptApi<'_>| {
            script.TestDynamicContainersOps(api, true);
        },
        14157752502587440361u64 => | script: &mut TypesCsScript, params: &[Value], api: &mut ScriptApi<'_>| {
            script.TestStaticContainersOps(api, true);
        },

    };
