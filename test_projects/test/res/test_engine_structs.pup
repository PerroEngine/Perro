@script TestEngineStructs extends Node2D

// Test 1: Accessing nested engine struct members on self
// self.transform.position.x should generate:
// api.read_node(self.id, |self_node: &Node2D| self_node.transform.position.x)
func test_nested_access() {
    var pos = self.transform.position
    var x = self.transform.position.x
    var y = self.transform.position.y
    
    // Test deeper nesting
    var scale_x = self.transform.scale.x
}

// Test 2: Creating engine struct instances
func test_constructors() {
    // Create a Vector2 with new
    var p = new Vector2()
    var p2 = new Vector2(10.0, 20.0)
    
    // Create a Transform2D
    var t = new Transform2D()
    
    // Create a Color
    var c = new Color()
}

// Test 3: Assigning to variables and accessing members
func test_variable_access() {
    var pos = self.transform.position
    var x_val = pos.x
    var y_val = pos.y
    
    // Chain access
    var combined = pos.x + pos.y
}

// Test 4: Modifying nested engine struct members
func test_modification() {
    self.transform.position.x = 100.0
    self.transform.position.y = 200.0
    self.transform.rotation = 3.14
    self.transform.scale.x = 2.0
}

// Test 5: Using engine structs in expressions
func test_expressions() {
    var speed = 5.0
    self.transform.position.x = self.transform.position.x + speed
    self.transform.position.y = self.transform.position.y + speed
}

// Test 6: Passing engine structs as parameters
func set_position(pos: Vector2) {
    self.transform.position = pos
}

func test_parameters() {
    var new_pos = new Vector2(50.0, 75.0)
    self.set_position(new_pos)
}

// Test 7: Returning engine structs
func get_position() -> Vector2 {
    return self.transform.position
}

func test_return_values() {
    var current_pos = self.get_position()
    var x = current_pos.x
}

